-- ************************************************************************
--
-- Description:
--
-- Rapid Enquiry Facility (RIF) - Tile maker - Create processed CSV tables created 
-- from shapefiles simplification
--
-- Copyright:
--
-- The Rapid Inquiry Facility (RIF) is an automated tool devised by SAHSU 
-- that rapidly addresses epidemiological and public health questions using 
-- routinely collected health and population data and generates standardised 
-- rates and relative risks for any given health outcome, for specified age 
-- and year ranges, for any given geographical area.
--
-- Copyright 2014 Imperial College London, developed by the Small Area
-- Health Statistics Unit. The work of the Small Area Health Statistics Unit 
-- is funded by the Public Health England as part of the MRC-PHE Centre for 
-- Environment and Health. Funding for this project has also been received 
-- from the Centers for Disease Control and Prevention.  
--
-- This file is part of the Rapid Inquiry Facility (RIF) project.
-- RIF is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Lesser General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- RIF is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU Lesser General Public License for more details.
--
-- You should have received a copy of the GNU Lesser General Public License
-- along with RIF. If not, see <http://www.gnu.org/licenses/>; or write 
-- to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
-- Boston, MA 02110-1301 USA
--
-- Author:
--
-- Peter Hambly, SAHSU
--
-- This script is autogenerated.
--
--
-- MS SQL Server specific parameters
--
-- Usage: sqlcmd -E -b -m-1 -e -i mssql_cb_2014_us_500k.sql -v pwd="%cd%"
-- Connect flags if required: -U <username>/-E -S<myServerinstanceName>
--
-- You must set the current schema if you cannot write to the default schema!
-- You need create privilege for the various object and the bulkadmin role
--
-- USE <my database>;
--
SET QUOTED_IDENTIFIER ON;
-- SET STATISTICS TIME ON;
-- SQL statement 0: Start transaction >>>
BEGIN TRANSACTION;
GO

-- SQL statement 1: Drop table cb_2014_us_county_500k >>>
IF OBJECT_ID('cb_2014_us_county_500k', 'U') IS NOT NULL DROP TABLE cb_2014_us_county_500k;
GO

-- SQL statement 2: Create tablecb_2014_us_county_500k >>>
CREATE TABLE cb_2014_us_county_500k (
	statefp                        	text,
	countyfp                       	text,
	countyns                       	text,
	affgeoid                       	text,
	geoid                          	text,
	name                           	text,
	lsad                           	text,
	aland                          	text,
	awater                         	text,
	gid                            	integer	NOT NULL,
	areaid                         	varchar(100)	NOT NULL,
	areaname                       	varchar(1000)	NOT NULL,
	area_km2                       	numeric,
	geographic_centroid_wkt        	text,
	wkt_11                         	text,
	wkt_10                         	text,
	wkt_9                          	text,
	wkt_8                          	text,
	wkt_7                          	text,
	wkt_6                          	text);
GO

-- SQL statement 3: Comment geospatial data table >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_table.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'The State-County at a scale of 1:500,000',
   'user', @CurrentUser,   
   'table', 'cb_2014_us_county_500k';
GO

-- SQL statement 4: Load table from CSV file >>>
BULK INSERT cb_2014_us_county_500k
FROM '$(pwd)/cb_2014_us_county_500k.csv'	-- Note use of pwd; set via -v pwd="%cd%" in the sqlcmd command line
WITH
(
	FORMATFILE = '$(pwd)/mssql_cb_2014_us_county_500k.fmt',		-- Use a format file
	TABLOCK,					-- Table lock
    DATAFILETYPE = 'widechar' -- Handle Unicode
);
GO

-- SQL statement 5: Row check: 3233 >>>
DECLARE c1 CURSOR FOR SELECT COUNT(gid) AS total FROM cb_2014_us_county_500k;
/*
 * SQL statement name: 	csvfile_rowcheck.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: Expected number of rows; e.g. 3233
 *						3: Column to count; e.g. gid
 *
 * Description:			Check number of rows in loaded CSV file is as expected
 * Note:				%% becomes % after substitution
 */
DECLARE @c1_total AS int;
OPEN c1;
FETCH NEXT FROM c1 INTO @c1_total;
IF @c1_total = 3233
	PRINT 'Table: cb_2014_us_county_500k row check OK: ' + CAST(@c1_total AS VARCHAR);
ELSE
	RAISERROR('Table: cb_2014_us_county_500k row check FAILED: expected: 3233 got: %i', 16, 1, @c1_total);
CLOSE c1;
DEALLOCATE c1;;
GO

-- SQL statement 6: Add primary key cb_2014_us_county_500k >>>
ALTER TABLE cb_2014_us_county_500k ADD PRIMARY KEY (gid);
GO

-- SQL statement 7: Add unique key cb_2014_us_county_500k >>>
/*
 * SQL statement name: 	add_unique_key.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: table; e.g. cb_2014_us_nation_5m
 *						2: constraint name; e.g. cb_2014_us_nation_5m_uk
 *						3: fields; e.g. areaid
 *
 * Description:			Add unique key constraint
 * Note:				%% becomes % after substitution
 */
ALTER TABLE cb_2014_us_county_500k ADD CONSTRAINT cb_2014_us_county_500k_uk UNIQUE(areaid);
GO

--
-- Add geometric  data
--

-- SQL statement 9: Add geometry column: geographic centroid >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 *
 * May need to be swapped to geometry to be the same datatype as PostGIS:
 * ALTER TABLE cb_2014_us_county_500k ADD geographic_centroid geometry
 */
ALTER TABLE cb_2014_us_county_500k ADD geographic_centroid geography;
GO

-- SQL statement 10: Add geometry column for original SRID geometry >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 *
 * May need to be swapped to geometry to be the same datatype as PostGIS:
 * ALTER TABLE cb_2014_us_county_500k ADD geom_orig geometry
 */
ALTER TABLE cb_2014_us_county_500k ADD geom_orig geography;
GO

-- SQL statement 11: Add geometry column for zoomlevel: 6 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 *
 * May need to be swapped to geometry to be the same datatype as PostGIS:
 * ALTER TABLE cb_2014_us_county_500k ADD geom_6 geometry
 */
ALTER TABLE cb_2014_us_county_500k ADD geom_6 geography;
GO

-- SQL statement 12: Add geometry column for zoomlevel: 7 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 *
 * May need to be swapped to geometry to be the same datatype as PostGIS:
 * ALTER TABLE cb_2014_us_county_500k ADD geom_7 geometry
 */
ALTER TABLE cb_2014_us_county_500k ADD geom_7 geography;
GO

-- SQL statement 13: Add geometry column for zoomlevel: 8 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 *
 * May need to be swapped to geometry to be the same datatype as PostGIS:
 * ALTER TABLE cb_2014_us_county_500k ADD geom_8 geometry
 */
ALTER TABLE cb_2014_us_county_500k ADD geom_8 geography;
GO

-- SQL statement 14: Add geometry column for zoomlevel: 9 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 *
 * May need to be swapped to geometry to be the same datatype as PostGIS:
 * ALTER TABLE cb_2014_us_county_500k ADD geom_9 geometry
 */
ALTER TABLE cb_2014_us_county_500k ADD geom_9 geography;
GO

-- SQL statement 15: Add geometry column for zoomlevel: 10 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 *
 * May need to be swapped to geometry to be the same datatype as PostGIS:
 * ALTER TABLE cb_2014_us_county_500k ADD geom_10 geometry
 */
ALTER TABLE cb_2014_us_county_500k ADD geom_10 geography;
GO

-- SQL statement 16: Add geometry column for zoomlevel: 11 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 *
 * May need to be swapped to geometry to be the same datatype as PostGIS:
 * ALTER TABLE cb_2014_us_county_500k ADD geom_11 geometry
 */
ALTER TABLE cb_2014_us_county_500k ADD geom_11 geography;
GO

-- SQL statement 17: Update geographic centroid, geometry columns, handle polygons and mutlipolygons, convert highest zoomlevel to original SRID >>>
UPDATE cb_2014_us_county_500k
   SET geographic_centroid = geography::STGeomFromText(geographic_centroid_wkt, 4326),
       geom_6 = geography::STGeomFromText(wkt_6, 4326).MakeValid(),
       geom_7 = geography::STGeomFromText(wkt_7, 4326).MakeValid(),
       geom_8 = geography::STGeomFromText(wkt_8, 4326).MakeValid(),
       geom_9 = geography::STGeomFromText(wkt_9, 4326).MakeValid(),
       geom_10 = geography::STGeomFromText(wkt_10, 4326).MakeValid(),
       geom_11 = geography::STGeomFromText(wkt_11, 4326).MakeValid(),
       geom_orig = /* geography::STTransform(geography::STGeomFromText(wkt_11, 4326).MakeValid(), 4269) NOT POSSIBLE */ NULL;
GO

--
-- Test geometry and make valid if required
--

-- SQL statement 19: Check validity of geometry columns >>>
DECLARE c1 CURSOR FOR
SELECT areaname,
       6 AS geolevel,
       geom_6.IsValidDetailed() AS reason
  FROM cb_2014_us_county_500k
 WHERE geom_6.STIsValid() = 0
UNION
SELECT areaname,
       7 AS geolevel,
       geom_7.IsValidDetailed() AS reason
  FROM cb_2014_us_county_500k
 WHERE geom_7.STIsValid() = 0
UNION
SELECT areaname,
       8 AS geolevel,
       geom_8.IsValidDetailed() AS reason
  FROM cb_2014_us_county_500k
 WHERE geom_8.STIsValid() = 0
UNION
SELECT areaname,
       9 AS geolevel,
       geom_9.IsValidDetailed() AS reason
  FROM cb_2014_us_county_500k
 WHERE geom_9.STIsValid() = 0
UNION
SELECT areaname,
       10 AS geolevel,
       geom_10.IsValidDetailed() AS reason
  FROM cb_2014_us_county_500k
 WHERE geom_10.STIsValid() = 0
UNION
SELECT areaname,
       11 AS geolevel,
       geom_11.IsValidDetailed() AS reason
  FROM cb_2014_us_county_500k
 WHERE geom_11.STIsValid() = 0
ORDER BY 1, 2;
DECLARE @areaname AS VARCHAR(30);
DECLARE @geolevel AS int;
DECLARE @reason AS VARCHAR(90);
DECLARE @nrows AS int;
SET @nrows=0;
OPEN c1;
FETCH NEXT FROM c1 INTO @areaname, @geolevel, @reason;
WHILE @@FETCH_STATUS = 0
BEGIN
		SET @nrows+=1;
	    PRINT 'Area: ' + @areaname + ', geolevel: ' + CAST(@geolevel AS VARCHAR) + ': ' +RTRIM(@reason);
       FETCH NEXT FROM c1 INTO @areaname, @geolevel, @reason;
END
IF @nrows = 0
	PRINT 'Table: cb_2014_us_county_500k no invalid geometry check OK';
ELSE
	RAISERROR('Table: cb_2014_us_county_500k no invalid geometry check FAILED: %i invalid', 16, 1, @nrows);
CLOSE c1;
DEALLOCATE c1;
GO

--
-- Make all polygons right handed
--

-- SQL statement 21: Make all polygons right handed for zoomlevel: 6 >>>
/*
 * SQL statement name: 	force_rhr.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Create insert statement into hierarchy table
 * Note:				%% becomes % after substitution
 * 						c.geom_6.STUnion(geom_6.STStartPoint()) is also possible instead of c.geom_6.ReorientObject()
 */
WITH a AS (
	SELECT gid, geom_6,
		   CAST(area_km2 AS NUMERIC(21,6)) AS area_km2,
		   CAST((geom_6.STArea()/(1000*1000)) AS NUMERIC(21,6)) AS area_km2_calc
	  FROM cb_2014_us_county_500k
), b AS (
	SELECT a.gid,
	       a.geom_6,
           a.area_km2,
	       a.area_km2_calc,
          CASE WHEN a.area_km2 > 0 THEN CAST(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2) AS NUMERIC(21,6))
				WHEN a.area_km2 = a.area_km2_calc THEN 0
	        	ELSE NULL
	   	   END AS pct_km2_diff 
  FROM a
)
UPDATE cb_2014_us_county_500k
   SET geom_6 = c.geom_6.ReorientObject()
  FROM cb_2014_us_county_500k c
 JOIN b ON b.gid = c.gid
 WHERE b.pct_km2_diff > 200 /* Threshold test */;
GO

-- SQL statement 22: Make all polygons right handed for zoomlevel: 7 >>>
/*
 * SQL statement name: 	force_rhr.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Create insert statement into hierarchy table
 * Note:				%% becomes % after substitution
 * 						c.geom_7.STUnion(geom_7.STStartPoint()) is also possible instead of c.geom_7.ReorientObject()
 */
WITH a AS (
	SELECT gid, geom_7,
		   CAST(area_km2 AS NUMERIC(21,6)) AS area_km2,
		   CAST((geom_7.STArea()/(1000*1000)) AS NUMERIC(21,6)) AS area_km2_calc
	  FROM cb_2014_us_county_500k
), b AS (
	SELECT a.gid,
	       a.geom_7,
           a.area_km2,
	       a.area_km2_calc,
          CASE WHEN a.area_km2 > 0 THEN CAST(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2) AS NUMERIC(21,6))
				WHEN a.area_km2 = a.area_km2_calc THEN 0
	        	ELSE NULL
	   	   END AS pct_km2_diff 
  FROM a
)
UPDATE cb_2014_us_county_500k
   SET geom_7 = c.geom_7.ReorientObject()
  FROM cb_2014_us_county_500k c
 JOIN b ON b.gid = c.gid
 WHERE b.pct_km2_diff > 200 /* Threshold test */;
GO

-- SQL statement 23: Make all polygons right handed for zoomlevel: 8 >>>
/*
 * SQL statement name: 	force_rhr.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Create insert statement into hierarchy table
 * Note:				%% becomes % after substitution
 * 						c.geom_8.STUnion(geom_8.STStartPoint()) is also possible instead of c.geom_8.ReorientObject()
 */
WITH a AS (
	SELECT gid, geom_8,
		   CAST(area_km2 AS NUMERIC(21,6)) AS area_km2,
		   CAST((geom_8.STArea()/(1000*1000)) AS NUMERIC(21,6)) AS area_km2_calc
	  FROM cb_2014_us_county_500k
), b AS (
	SELECT a.gid,
	       a.geom_8,
           a.area_km2,
	       a.area_km2_calc,
          CASE WHEN a.area_km2 > 0 THEN CAST(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2) AS NUMERIC(21,6))
				WHEN a.area_km2 = a.area_km2_calc THEN 0
	        	ELSE NULL
	   	   END AS pct_km2_diff 
  FROM a
)
UPDATE cb_2014_us_county_500k
   SET geom_8 = c.geom_8.ReorientObject()
  FROM cb_2014_us_county_500k c
 JOIN b ON b.gid = c.gid
 WHERE b.pct_km2_diff > 200 /* Threshold test */;
GO

-- SQL statement 24: Make all polygons right handed for zoomlevel: 9 >>>
/*
 * SQL statement name: 	force_rhr.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Create insert statement into hierarchy table
 * Note:				%% becomes % after substitution
 * 						c.geom_9.STUnion(geom_9.STStartPoint()) is also possible instead of c.geom_9.ReorientObject()
 */
WITH a AS (
	SELECT gid, geom_9,
		   CAST(area_km2 AS NUMERIC(21,6)) AS area_km2,
		   CAST((geom_9.STArea()/(1000*1000)) AS NUMERIC(21,6)) AS area_km2_calc
	  FROM cb_2014_us_county_500k
), b AS (
	SELECT a.gid,
	       a.geom_9,
           a.area_km2,
	       a.area_km2_calc,
          CASE WHEN a.area_km2 > 0 THEN CAST(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2) AS NUMERIC(21,6))
				WHEN a.area_km2 = a.area_km2_calc THEN 0
	        	ELSE NULL
	   	   END AS pct_km2_diff 
  FROM a
)
UPDATE cb_2014_us_county_500k
   SET geom_9 = c.geom_9.ReorientObject()
  FROM cb_2014_us_county_500k c
 JOIN b ON b.gid = c.gid
 WHERE b.pct_km2_diff > 200 /* Threshold test */;
GO

-- SQL statement 25: Make all polygons right handed for zoomlevel: 10 >>>
/*
 * SQL statement name: 	force_rhr.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Create insert statement into hierarchy table
 * Note:				%% becomes % after substitution
 * 						c.geom_10.STUnion(geom_10.STStartPoint()) is also possible instead of c.geom_10.ReorientObject()
 */
WITH a AS (
	SELECT gid, geom_10,
		   CAST(area_km2 AS NUMERIC(21,6)) AS area_km2,
		   CAST((geom_10.STArea()/(1000*1000)) AS NUMERIC(21,6)) AS area_km2_calc
	  FROM cb_2014_us_county_500k
), b AS (
	SELECT a.gid,
	       a.geom_10,
           a.area_km2,
	       a.area_km2_calc,
          CASE WHEN a.area_km2 > 0 THEN CAST(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2) AS NUMERIC(21,6))
				WHEN a.area_km2 = a.area_km2_calc THEN 0
	        	ELSE NULL
	   	   END AS pct_km2_diff 
  FROM a
)
UPDATE cb_2014_us_county_500k
   SET geom_10 = c.geom_10.ReorientObject()
  FROM cb_2014_us_county_500k c
 JOIN b ON b.gid = c.gid
 WHERE b.pct_km2_diff > 200 /* Threshold test */;
GO

-- SQL statement 26: Make all polygons right handed for zoomlevel: 11 >>>
/*
 * SQL statement name: 	force_rhr.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Create insert statement into hierarchy table
 * Note:				%% becomes % after substitution
 * 						c.geom_11.STUnion(geom_11.STStartPoint()) is also possible instead of c.geom_11.ReorientObject()
 */
WITH a AS (
	SELECT gid, geom_11,
		   CAST(area_km2 AS NUMERIC(21,6)) AS area_km2,
		   CAST((geom_11.STArea()/(1000*1000)) AS NUMERIC(21,6)) AS area_km2_calc
	  FROM cb_2014_us_county_500k
), b AS (
	SELECT a.gid,
	       a.geom_11,
           a.area_km2,
	       a.area_km2_calc,
          CASE WHEN a.area_km2 > 0 THEN CAST(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2) AS NUMERIC(21,6))
				WHEN a.area_km2 = a.area_km2_calc THEN 0
	        	ELSE NULL
	   	   END AS pct_km2_diff 
  FROM a
)
UPDATE cb_2014_us_county_500k
   SET geom_11 = c.geom_11.ReorientObject()
  FROM cb_2014_us_county_500k c
 JOIN b ON b.gid = c.gid
 WHERE b.pct_km2_diff > 200 /* Threshold test */;
GO

--
-- Test Turf and DB areas agree to within 1%
--

-- SQL statement 28: Test Turf and DB areas agree to within 1% (Postgres)/5% (SQL server) >>>
DECLARE c1 CURSOR FOR
/*
 * SQL statement name: 	area_check.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Check Turf araa (area_km2) compared to SQL Server calculated area (area_km2_calc)
 *						Allow for 5% error
 *						Ignore small areas <= 10 km2
 * Note:				%% becomes % after substitution
 */
	WITH a AS (
		SELECT areaname,
			   CAST(area_km2 AS NUMERIC(15,2)) AS area_km2,
			   CAST((geom_11.STArea()/(1000*1000)) AS NUMERIC(15,2)) AS area_km2_calc
		  FROM cb_2014_us_county_500k
	), b AS (
	SELECT SUBSTRING(a.areaname, 1, 30) AS areaname,
		   a.area_km2,
		   a.area_km2_calc,
		   CASE WHEN a.area_km2 > 0 THEN CAST(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2) AS NUMERIC(15,2))
				WHEN a.area_km2 = a.area_km2_calc THEN 0
				ELSE NULL
		   END AS pct_km2_diff
	  FROM a
	)
	SELECT b.areaname, b.area_km2, b.area_km2_calc, b.pct_km2_diff
	  FROM b
	 WHERE b.pct_km2_diff > 5 /* Allow for 5% error */
	   AND b.area_km2_calc > 10 /* Ignore small areas <= 10 km2 */;
DECLARE @areaname AS VARCHAR(30);
DECLARE @area_km2 AS NUMERIC(15,2);
DECLARE @area_km2_calc AS NUMERIC(15,2);
DECLARE @pct_km2_diff AS NUMERIC(15,2);
DECLARE @nrows AS int;
SET @nrows=0;
OPEN c1;
FETCH NEXT FROM c1 INTO @areaname, @area_km2, @area_km2_calc, @pct_km2_diff;
WHILE @@FETCH_STATUS = 0
BEGIN
		SET @nrows+=1;
		PRINT 'Area: ' + @areaname + ', area km2: ' + CAST(@area_km2 AS VARCHAR) +  + ', calc: ' +
			CAST(@area_km2_calc AS VARCHAR) + ', diff: ' + CAST(@pct_km2_diff AS VARCHAR);
		FETCH NEXT FROM c1 INTO @areaname, @area_km2, @area_km2_calc, @pct_km2_diff;
END
IF @nrows = 0
	PRINT 'Table: cb_2014_us_county_500k no invalid areas check OK';
ELSE
	RAISERROR('Table: cb_2014_us_county_500k no invalid areas check FAILED: %i invalid', 16, 1, @nrows);
CLOSE c1;
DEALLOCATE c1;
GO

--
-- Create spatial indexes
--

-- SQL statement 30: Index geometry column for zoomlevel: 6 >>>
CREATE SPATIAL INDEX cb_2014_us_county_500k_geom_6_gix ON cb_2014_us_county_500k (geom_6);
GO

-- SQL statement 31: Index geometry column for zoomlevel: 7 >>>
CREATE SPATIAL INDEX cb_2014_us_county_500k_geom_7_gix ON cb_2014_us_county_500k (geom_7);
GO

-- SQL statement 32: Index geometry column for zoomlevel: 8 >>>
CREATE SPATIAL INDEX cb_2014_us_county_500k_geom_8_gix ON cb_2014_us_county_500k (geom_8);
GO

-- SQL statement 33: Index geometry column for zoomlevel: 9 >>>
CREATE SPATIAL INDEX cb_2014_us_county_500k_geom_9_gix ON cb_2014_us_county_500k (geom_9);
GO

-- SQL statement 34: Index geometry column for zoomlevel: 10 >>>
CREATE SPATIAL INDEX cb_2014_us_county_500k_geom_10_gix ON cb_2014_us_county_500k (geom_10);
GO

-- SQL statement 35: Index geometry column for zoomlevel: 11 >>>
CREATE SPATIAL INDEX cb_2014_us_county_500k_geom_11_gix ON cb_2014_us_county_500k (geom_11);
GO

-- SQL statement 36: Index geometry column for original SRID geometry >>>
CREATE SPATIAL INDEX cb_2014_us_county_500k_geom_orig_gix ON cb_2014_us_county_500k (geom_orig);
GO

--
-- Reports
--

-- SQL statement 38: Areas and centroids report >>>
/*
 * SQL statement name: 	area_centroid_report.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Area and centroids report
 * Note:				% becomes % after substitution
 */
WITH a AS (
	SELECT areaname, geom_11,
		   CAST(area_km2 AS NUMERIC(15,2)) AS area_km2,
		   CAST((geom_11.STArea()/(1000*1000)) AS NUMERIC(15,2)) AS area_km2_calc,
		   CONCAT(
				CAST(CAST(geographic_centroid.Long AS NUMERIC(15,7)) AS VARCHAR(30)),
				',',
				CAST(CAST(geographic_centroid.Lat AS NUMERIC(15,7)) AS VARCHAR(30))
				) AS geographic_centroid,
		   CONCAT(
				CAST(CAST(geom_11.EnvelopeCenter().Long AS NUMERIC(15,7)) AS VARCHAR(30)),
				',',
				CAST(CAST(geom_11.EnvelopeCenter().Lat AS NUMERIC(15,7)) AS VARCHAR(30))
				) AS geographic_centroid_calc,
		   CAST((geom_11.EnvelopeCenter().STDistance(geographic_centroid))/1000 AS VARCHAR(30)) AS centroid_diff_km,
		   ROW_NUMBER() OVER (ORDER BY areaname) as nrow
	  FROM cb_2014_us_county_500k
)
SELECT SUBSTRING(a.areaname, 1, 30) AS areaname,
       a.area_km2,
	   a.area_km2_calc,
	   CAST(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2) AS NUMERIC(15,2)) AS pct_km2_diff,
	   a.geographic_centroid,
       a.geographic_centroid_calc,
	   a.centroid_diff_km
  FROM a
 WHERE nrow <= 100
 ORDER BY 1 ;
GO

-- SQL statement 39: Drop table cb_2014_us_nation_5m >>>
IF OBJECT_ID('cb_2014_us_nation_5m', 'U') IS NOT NULL DROP TABLE cb_2014_us_nation_5m;
GO

-- SQL statement 40: Create tablecb_2014_us_nation_5m >>>
CREATE TABLE cb_2014_us_nation_5m (
	affgeoid                       	text,
	geoid                          	text,
	name                           	text,
	gid                            	integer	NOT NULL,
	areaid                         	varchar(100)	NOT NULL,
	areaname                       	varchar(1000)	NOT NULL,
	area_km2                       	numeric,
	geographic_centroid_wkt        	text,
	wkt_11                         	text,
	wkt_10                         	text,
	wkt_9                          	text,
	wkt_8                          	text,
	wkt_7                          	text,
	wkt_6                          	text);
GO

-- SQL statement 41: Comment geospatial data table >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_table.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'Theat a scale of 1:5,000,000',
   'user', @CurrentUser,   
   'table', 'cb_2014_us_nation_5m';
GO

-- SQL statement 42: Load table from CSV file >>>
BULK INSERT cb_2014_us_nation_5m
FROM '$(pwd)/cb_2014_us_nation_5m.csv'	-- Note use of pwd; set via -v pwd="%cd%" in the sqlcmd command line
WITH
(
	FORMATFILE = '$(pwd)/mssql_cb_2014_us_nation_5m.fmt',		-- Use a format file
	TABLOCK,					-- Table lock
    DATAFILETYPE = 'widechar' -- Handle Unicode
);
GO

-- SQL statement 43: Row check: 1 >>>
DECLARE c1 CURSOR FOR SELECT COUNT(gid) AS total FROM cb_2014_us_nation_5m;
/*
 * SQL statement name: 	csvfile_rowcheck.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: Expected number of rows; e.g. 3233
 *						3: Column to count; e.g. gid
 *
 * Description:			Check number of rows in loaded CSV file is as expected
 * Note:				%% becomes % after substitution
 */
DECLARE @c1_total AS int;
OPEN c1;
FETCH NEXT FROM c1 INTO @c1_total;
IF @c1_total = 1
	PRINT 'Table: cb_2014_us_nation_5m row check OK: ' + CAST(@c1_total AS VARCHAR);
ELSE
	RAISERROR('Table: cb_2014_us_nation_5m row check FAILED: expected: 1 got: %i', 16, 1, @c1_total);
CLOSE c1;
DEALLOCATE c1;;
GO

-- SQL statement 44: Add primary key cb_2014_us_nation_5m >>>
ALTER TABLE cb_2014_us_nation_5m ADD PRIMARY KEY (gid);
GO

-- SQL statement 45: Add unique key cb_2014_us_nation_5m >>>
/*
 * SQL statement name: 	add_unique_key.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: table; e.g. cb_2014_us_nation_5m
 *						2: constraint name; e.g. cb_2014_us_nation_5m_uk
 *						3: fields; e.g. areaid
 *
 * Description:			Add unique key constraint
 * Note:				%% becomes % after substitution
 */
ALTER TABLE cb_2014_us_nation_5m ADD CONSTRAINT cb_2014_us_nation_5m_uk UNIQUE(areaid);
GO

--
-- Add geometric  data
--

-- SQL statement 47: Add geometry column: geographic centroid >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 *
 * May need to be swapped to geometry to be the same datatype as PostGIS:
 * ALTER TABLE cb_2014_us_nation_5m ADD geographic_centroid geometry
 */
ALTER TABLE cb_2014_us_nation_5m ADD geographic_centroid geography;
GO

-- SQL statement 48: Add geometry column for original SRID geometry >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 *
 * May need to be swapped to geometry to be the same datatype as PostGIS:
 * ALTER TABLE cb_2014_us_nation_5m ADD geom_orig geometry
 */
ALTER TABLE cb_2014_us_nation_5m ADD geom_orig geography;
GO

-- SQL statement 49: Add geometry column for zoomlevel: 6 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 *
 * May need to be swapped to geometry to be the same datatype as PostGIS:
 * ALTER TABLE cb_2014_us_nation_5m ADD geom_6 geometry
 */
ALTER TABLE cb_2014_us_nation_5m ADD geom_6 geography;
GO

-- SQL statement 50: Add geometry column for zoomlevel: 7 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 *
 * May need to be swapped to geometry to be the same datatype as PostGIS:
 * ALTER TABLE cb_2014_us_nation_5m ADD geom_7 geometry
 */
ALTER TABLE cb_2014_us_nation_5m ADD geom_7 geography;
GO

-- SQL statement 51: Add geometry column for zoomlevel: 8 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 *
 * May need to be swapped to geometry to be the same datatype as PostGIS:
 * ALTER TABLE cb_2014_us_nation_5m ADD geom_8 geometry
 */
ALTER TABLE cb_2014_us_nation_5m ADD geom_8 geography;
GO

-- SQL statement 52: Add geometry column for zoomlevel: 9 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 *
 * May need to be swapped to geometry to be the same datatype as PostGIS:
 * ALTER TABLE cb_2014_us_nation_5m ADD geom_9 geometry
 */
ALTER TABLE cb_2014_us_nation_5m ADD geom_9 geography;
GO

-- SQL statement 53: Add geometry column for zoomlevel: 10 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 *
 * May need to be swapped to geometry to be the same datatype as PostGIS:
 * ALTER TABLE cb_2014_us_nation_5m ADD geom_10 geometry
 */
ALTER TABLE cb_2014_us_nation_5m ADD geom_10 geography;
GO

-- SQL statement 54: Add geometry column for zoomlevel: 11 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 *
 * May need to be swapped to geometry to be the same datatype as PostGIS:
 * ALTER TABLE cb_2014_us_nation_5m ADD geom_11 geometry
 */
ALTER TABLE cb_2014_us_nation_5m ADD geom_11 geography;
GO

-- SQL statement 55: Update geographic centroid, geometry columns, handle polygons and mutlipolygons, convert highest zoomlevel to original SRID >>>
UPDATE cb_2014_us_nation_5m
   SET geographic_centroid = geography::STGeomFromText(geographic_centroid_wkt, 4326),
       geom_6 = geography::STGeomFromText(wkt_6, 4326).MakeValid(),
       geom_7 = geography::STGeomFromText(wkt_7, 4326).MakeValid(),
       geom_8 = geography::STGeomFromText(wkt_8, 4326).MakeValid(),
       geom_9 = geography::STGeomFromText(wkt_9, 4326).MakeValid(),
       geom_10 = geography::STGeomFromText(wkt_10, 4326).MakeValid(),
       geom_11 = geography::STGeomFromText(wkt_11, 4326).MakeValid(),
       geom_orig = /* geography::STTransform(geography::STGeomFromText(wkt_11, 4326).MakeValid(), 4269) NOT POSSIBLE */ NULL;
GO

--
-- Test geometry and make valid if required
--

-- SQL statement 57: Check validity of geometry columns >>>
DECLARE c1 CURSOR FOR
SELECT areaname,
       6 AS geolevel,
       geom_6.IsValidDetailed() AS reason
  FROM cb_2014_us_nation_5m
 WHERE geom_6.STIsValid() = 0
UNION
SELECT areaname,
       7 AS geolevel,
       geom_7.IsValidDetailed() AS reason
  FROM cb_2014_us_nation_5m
 WHERE geom_7.STIsValid() = 0
UNION
SELECT areaname,
       8 AS geolevel,
       geom_8.IsValidDetailed() AS reason
  FROM cb_2014_us_nation_5m
 WHERE geom_8.STIsValid() = 0
UNION
SELECT areaname,
       9 AS geolevel,
       geom_9.IsValidDetailed() AS reason
  FROM cb_2014_us_nation_5m
 WHERE geom_9.STIsValid() = 0
UNION
SELECT areaname,
       10 AS geolevel,
       geom_10.IsValidDetailed() AS reason
  FROM cb_2014_us_nation_5m
 WHERE geom_10.STIsValid() = 0
UNION
SELECT areaname,
       11 AS geolevel,
       geom_11.IsValidDetailed() AS reason
  FROM cb_2014_us_nation_5m
 WHERE geom_11.STIsValid() = 0
ORDER BY 1, 2;
DECLARE @areaname AS VARCHAR(30);
DECLARE @geolevel AS int;
DECLARE @reason AS VARCHAR(90);
DECLARE @nrows AS int;
SET @nrows=0;
OPEN c1;
FETCH NEXT FROM c1 INTO @areaname, @geolevel, @reason;
WHILE @@FETCH_STATUS = 0
BEGIN
		SET @nrows+=1;
	    PRINT 'Area: ' + @areaname + ', geolevel: ' + CAST(@geolevel AS VARCHAR) + ': ' +RTRIM(@reason);
       FETCH NEXT FROM c1 INTO @areaname, @geolevel, @reason;
END
IF @nrows = 0
	PRINT 'Table: cb_2014_us_nation_5m no invalid geometry check OK';
ELSE
	RAISERROR('Table: cb_2014_us_nation_5m no invalid geometry check FAILED: %i invalid', 16, 1, @nrows);
CLOSE c1;
DEALLOCATE c1;
GO

--
-- Make all polygons right handed
--

-- SQL statement 59: Make all polygons right handed for zoomlevel: 6 >>>
/*
 * SQL statement name: 	force_rhr.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Create insert statement into hierarchy table
 * Note:				%% becomes % after substitution
 * 						c.geom_6.STUnion(geom_6.STStartPoint()) is also possible instead of c.geom_6.ReorientObject()
 */
WITH a AS (
	SELECT gid, geom_6,
		   CAST(area_km2 AS NUMERIC(21,6)) AS area_km2,
		   CAST((geom_6.STArea()/(1000*1000)) AS NUMERIC(21,6)) AS area_km2_calc
	  FROM cb_2014_us_nation_5m
), b AS (
	SELECT a.gid,
	       a.geom_6,
           a.area_km2,
	       a.area_km2_calc,
          CASE WHEN a.area_km2 > 0 THEN CAST(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2) AS NUMERIC(21,6))
				WHEN a.area_km2 = a.area_km2_calc THEN 0
	        	ELSE NULL
	   	   END AS pct_km2_diff 
  FROM a
)
UPDATE cb_2014_us_nation_5m
   SET geom_6 = c.geom_6.ReorientObject()
  FROM cb_2014_us_nation_5m c
 JOIN b ON b.gid = c.gid
 WHERE b.pct_km2_diff > 200 /* Threshold test */;
GO

-- SQL statement 60: Make all polygons right handed for zoomlevel: 7 >>>
/*
 * SQL statement name: 	force_rhr.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Create insert statement into hierarchy table
 * Note:				%% becomes % after substitution
 * 						c.geom_7.STUnion(geom_7.STStartPoint()) is also possible instead of c.geom_7.ReorientObject()
 */
WITH a AS (
	SELECT gid, geom_7,
		   CAST(area_km2 AS NUMERIC(21,6)) AS area_km2,
		   CAST((geom_7.STArea()/(1000*1000)) AS NUMERIC(21,6)) AS area_km2_calc
	  FROM cb_2014_us_nation_5m
), b AS (
	SELECT a.gid,
	       a.geom_7,
           a.area_km2,
	       a.area_km2_calc,
          CASE WHEN a.area_km2 > 0 THEN CAST(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2) AS NUMERIC(21,6))
				WHEN a.area_km2 = a.area_km2_calc THEN 0
	        	ELSE NULL
	   	   END AS pct_km2_diff 
  FROM a
)
UPDATE cb_2014_us_nation_5m
   SET geom_7 = c.geom_7.ReorientObject()
  FROM cb_2014_us_nation_5m c
 JOIN b ON b.gid = c.gid
 WHERE b.pct_km2_diff > 200 /* Threshold test */;
GO

-- SQL statement 61: Make all polygons right handed for zoomlevel: 8 >>>
/*
 * SQL statement name: 	force_rhr.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Create insert statement into hierarchy table
 * Note:				%% becomes % after substitution
 * 						c.geom_8.STUnion(geom_8.STStartPoint()) is also possible instead of c.geom_8.ReorientObject()
 */
WITH a AS (
	SELECT gid, geom_8,
		   CAST(area_km2 AS NUMERIC(21,6)) AS area_km2,
		   CAST((geom_8.STArea()/(1000*1000)) AS NUMERIC(21,6)) AS area_km2_calc
	  FROM cb_2014_us_nation_5m
), b AS (
	SELECT a.gid,
	       a.geom_8,
           a.area_km2,
	       a.area_km2_calc,
          CASE WHEN a.area_km2 > 0 THEN CAST(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2) AS NUMERIC(21,6))
				WHEN a.area_km2 = a.area_km2_calc THEN 0
	        	ELSE NULL
	   	   END AS pct_km2_diff 
  FROM a
)
UPDATE cb_2014_us_nation_5m
   SET geom_8 = c.geom_8.ReorientObject()
  FROM cb_2014_us_nation_5m c
 JOIN b ON b.gid = c.gid
 WHERE b.pct_km2_diff > 200 /* Threshold test */;
GO

-- SQL statement 62: Make all polygons right handed for zoomlevel: 9 >>>
/*
 * SQL statement name: 	force_rhr.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Create insert statement into hierarchy table
 * Note:				%% becomes % after substitution
 * 						c.geom_9.STUnion(geom_9.STStartPoint()) is also possible instead of c.geom_9.ReorientObject()
 */
WITH a AS (
	SELECT gid, geom_9,
		   CAST(area_km2 AS NUMERIC(21,6)) AS area_km2,
		   CAST((geom_9.STArea()/(1000*1000)) AS NUMERIC(21,6)) AS area_km2_calc
	  FROM cb_2014_us_nation_5m
), b AS (
	SELECT a.gid,
	       a.geom_9,
           a.area_km2,
	       a.area_km2_calc,
          CASE WHEN a.area_km2 > 0 THEN CAST(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2) AS NUMERIC(21,6))
				WHEN a.area_km2 = a.area_km2_calc THEN 0
	        	ELSE NULL
	   	   END AS pct_km2_diff 
  FROM a
)
UPDATE cb_2014_us_nation_5m
   SET geom_9 = c.geom_9.ReorientObject()
  FROM cb_2014_us_nation_5m c
 JOIN b ON b.gid = c.gid
 WHERE b.pct_km2_diff > 200 /* Threshold test */;
GO

-- SQL statement 63: Make all polygons right handed for zoomlevel: 10 >>>
/*
 * SQL statement name: 	force_rhr.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Create insert statement into hierarchy table
 * Note:				%% becomes % after substitution
 * 						c.geom_10.STUnion(geom_10.STStartPoint()) is also possible instead of c.geom_10.ReorientObject()
 */
WITH a AS (
	SELECT gid, geom_10,
		   CAST(area_km2 AS NUMERIC(21,6)) AS area_km2,
		   CAST((geom_10.STArea()/(1000*1000)) AS NUMERIC(21,6)) AS area_km2_calc
	  FROM cb_2014_us_nation_5m
), b AS (
	SELECT a.gid,
	       a.geom_10,
           a.area_km2,
	       a.area_km2_calc,
          CASE WHEN a.area_km2 > 0 THEN CAST(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2) AS NUMERIC(21,6))
				WHEN a.area_km2 = a.area_km2_calc THEN 0
	        	ELSE NULL
	   	   END AS pct_km2_diff 
  FROM a
)
UPDATE cb_2014_us_nation_5m
   SET geom_10 = c.geom_10.ReorientObject()
  FROM cb_2014_us_nation_5m c
 JOIN b ON b.gid = c.gid
 WHERE b.pct_km2_diff > 200 /* Threshold test */;
GO

-- SQL statement 64: Make all polygons right handed for zoomlevel: 11 >>>
/*
 * SQL statement name: 	force_rhr.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Create insert statement into hierarchy table
 * Note:				%% becomes % after substitution
 * 						c.geom_11.STUnion(geom_11.STStartPoint()) is also possible instead of c.geom_11.ReorientObject()
 */
WITH a AS (
	SELECT gid, geom_11,
		   CAST(area_km2 AS NUMERIC(21,6)) AS area_km2,
		   CAST((geom_11.STArea()/(1000*1000)) AS NUMERIC(21,6)) AS area_km2_calc
	  FROM cb_2014_us_nation_5m
), b AS (
	SELECT a.gid,
	       a.geom_11,
           a.area_km2,
	       a.area_km2_calc,
          CASE WHEN a.area_km2 > 0 THEN CAST(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2) AS NUMERIC(21,6))
				WHEN a.area_km2 = a.area_km2_calc THEN 0
	        	ELSE NULL
	   	   END AS pct_km2_diff 
  FROM a
)
UPDATE cb_2014_us_nation_5m
   SET geom_11 = c.geom_11.ReorientObject()
  FROM cb_2014_us_nation_5m c
 JOIN b ON b.gid = c.gid
 WHERE b.pct_km2_diff > 200 /* Threshold test */;
GO

--
-- Test Turf and DB areas agree to within 1%
--

-- SQL statement 66: Test Turf and DB areas agree to within 1% (Postgres)/5% (SQL server) >>>
DECLARE c1 CURSOR FOR
/*
 * SQL statement name: 	area_check.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Check Turf araa (area_km2) compared to SQL Server calculated area (area_km2_calc)
 *						Allow for 5% error
 *						Ignore small areas <= 10 km2
 * Note:				%% becomes % after substitution
 */
	WITH a AS (
		SELECT areaname,
			   CAST(area_km2 AS NUMERIC(15,2)) AS area_km2,
			   CAST((geom_11.STArea()/(1000*1000)) AS NUMERIC(15,2)) AS area_km2_calc
		  FROM cb_2014_us_nation_5m
	), b AS (
	SELECT SUBSTRING(a.areaname, 1, 30) AS areaname,
		   a.area_km2,
		   a.area_km2_calc,
		   CASE WHEN a.area_km2 > 0 THEN CAST(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2) AS NUMERIC(15,2))
				WHEN a.area_km2 = a.area_km2_calc THEN 0
				ELSE NULL
		   END AS pct_km2_diff
	  FROM a
	)
	SELECT b.areaname, b.area_km2, b.area_km2_calc, b.pct_km2_diff
	  FROM b
	 WHERE b.pct_km2_diff > 5 /* Allow for 5% error */
	   AND b.area_km2_calc > 10 /* Ignore small areas <= 10 km2 */;
DECLARE @areaname AS VARCHAR(30);
DECLARE @area_km2 AS NUMERIC(15,2);
DECLARE @area_km2_calc AS NUMERIC(15,2);
DECLARE @pct_km2_diff AS NUMERIC(15,2);
DECLARE @nrows AS int;
SET @nrows=0;
OPEN c1;
FETCH NEXT FROM c1 INTO @areaname, @area_km2, @area_km2_calc, @pct_km2_diff;
WHILE @@FETCH_STATUS = 0
BEGIN
		SET @nrows+=1;
		PRINT 'Area: ' + @areaname + ', area km2: ' + CAST(@area_km2 AS VARCHAR) +  + ', calc: ' +
			CAST(@area_km2_calc AS VARCHAR) + ', diff: ' + CAST(@pct_km2_diff AS VARCHAR);
		FETCH NEXT FROM c1 INTO @areaname, @area_km2, @area_km2_calc, @pct_km2_diff;
END
IF @nrows = 0
	PRINT 'Table: cb_2014_us_nation_5m no invalid areas check OK';
ELSE
	RAISERROR('Table: cb_2014_us_nation_5m no invalid areas check FAILED: %i invalid', 16, 1, @nrows);
CLOSE c1;
DEALLOCATE c1;
GO

--
-- Create spatial indexes
--

-- SQL statement 68: Index geometry column for zoomlevel: 6 >>>
CREATE SPATIAL INDEX cb_2014_us_nation_5m_geom_6_gix ON cb_2014_us_nation_5m (geom_6);
GO

-- SQL statement 69: Index geometry column for zoomlevel: 7 >>>
CREATE SPATIAL INDEX cb_2014_us_nation_5m_geom_7_gix ON cb_2014_us_nation_5m (geom_7);
GO

-- SQL statement 70: Index geometry column for zoomlevel: 8 >>>
CREATE SPATIAL INDEX cb_2014_us_nation_5m_geom_8_gix ON cb_2014_us_nation_5m (geom_8);
GO

-- SQL statement 71: Index geometry column for zoomlevel: 9 >>>
CREATE SPATIAL INDEX cb_2014_us_nation_5m_geom_9_gix ON cb_2014_us_nation_5m (geom_9);
GO

-- SQL statement 72: Index geometry column for zoomlevel: 10 >>>
CREATE SPATIAL INDEX cb_2014_us_nation_5m_geom_10_gix ON cb_2014_us_nation_5m (geom_10);
GO

-- SQL statement 73: Index geometry column for zoomlevel: 11 >>>
CREATE SPATIAL INDEX cb_2014_us_nation_5m_geom_11_gix ON cb_2014_us_nation_5m (geom_11);
GO

-- SQL statement 74: Index geometry column for original SRID geometry >>>
CREATE SPATIAL INDEX cb_2014_us_nation_5m_geom_orig_gix ON cb_2014_us_nation_5m (geom_orig);
GO

--
-- Reports
--

-- SQL statement 76: Areas and centroids report >>>
/*
 * SQL statement name: 	area_centroid_report.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Area and centroids report
 * Note:				% becomes % after substitution
 */
WITH a AS (
	SELECT areaname, geom_11,
		   CAST(area_km2 AS NUMERIC(15,2)) AS area_km2,
		   CAST((geom_11.STArea()/(1000*1000)) AS NUMERIC(15,2)) AS area_km2_calc,
		   CONCAT(
				CAST(CAST(geographic_centroid.Long AS NUMERIC(15,7)) AS VARCHAR(30)),
				',',
				CAST(CAST(geographic_centroid.Lat AS NUMERIC(15,7)) AS VARCHAR(30))
				) AS geographic_centroid,
		   CONCAT(
				CAST(CAST(geom_11.EnvelopeCenter().Long AS NUMERIC(15,7)) AS VARCHAR(30)),
				',',
				CAST(CAST(geom_11.EnvelopeCenter().Lat AS NUMERIC(15,7)) AS VARCHAR(30))
				) AS geographic_centroid_calc,
		   CAST((geom_11.EnvelopeCenter().STDistance(geographic_centroid))/1000 AS VARCHAR(30)) AS centroid_diff_km,
		   ROW_NUMBER() OVER (ORDER BY areaname) as nrow
	  FROM cb_2014_us_nation_5m
)
SELECT SUBSTRING(a.areaname, 1, 30) AS areaname,
       a.area_km2,
	   a.area_km2_calc,
	   CAST(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2) AS NUMERIC(15,2)) AS pct_km2_diff,
	   a.geographic_centroid,
       a.geographic_centroid_calc,
	   a.centroid_diff_km
  FROM a
 WHERE nrow <= 100
 ORDER BY 1 ;
GO

-- SQL statement 77: Drop table cb_2014_us_state_500k >>>
IF OBJECT_ID('cb_2014_us_state_500k', 'U') IS NOT NULL DROP TABLE cb_2014_us_state_500k;
GO

-- SQL statement 78: Create tablecb_2014_us_state_500k >>>
CREATE TABLE cb_2014_us_state_500k (
	statefp                        	text,
	statens                        	text,
	affgeoid                       	text,
	geoid                          	text,
	stusps                         	text,
	name                           	text,
	lsad                           	text,
	aland                          	text,
	awater                         	text,
	gid                            	integer	NOT NULL,
	areaid                         	varchar(100)	NOT NULL,
	areaname                       	varchar(1000)	NOT NULL,
	area_km2                       	numeric,
	geographic_centroid_wkt        	text,
	wkt_11                         	text,
	wkt_10                         	text,
	wkt_9                          	text,
	wkt_8                          	text,
	wkt_7                          	text,
	wkt_6                          	text);
GO

-- SQL statement 79: Comment geospatial data table >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_table.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'The State at a scale of 1:500,000',
   'user', @CurrentUser,   
   'table', 'cb_2014_us_state_500k';
GO

-- SQL statement 80: Load table from CSV file >>>
BULK INSERT cb_2014_us_state_500k
FROM '$(pwd)/cb_2014_us_state_500k.csv'	-- Note use of pwd; set via -v pwd="%cd%" in the sqlcmd command line
WITH
(
	FORMATFILE = '$(pwd)/mssql_cb_2014_us_state_500k.fmt',		-- Use a format file
	TABLOCK,					-- Table lock
    DATAFILETYPE = 'widechar' -- Handle Unicode
);
GO

-- SQL statement 81: Row check: 56 >>>
DECLARE c1 CURSOR FOR SELECT COUNT(gid) AS total FROM cb_2014_us_state_500k;
/*
 * SQL statement name: 	csvfile_rowcheck.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: Expected number of rows; e.g. 3233
 *						3: Column to count; e.g. gid
 *
 * Description:			Check number of rows in loaded CSV file is as expected
 * Note:				%% becomes % after substitution
 */
DECLARE @c1_total AS int;
OPEN c1;
FETCH NEXT FROM c1 INTO @c1_total;
IF @c1_total = 56
	PRINT 'Table: cb_2014_us_state_500k row check OK: ' + CAST(@c1_total AS VARCHAR);
ELSE
	RAISERROR('Table: cb_2014_us_state_500k row check FAILED: expected: 56 got: %i', 16, 1, @c1_total);
CLOSE c1;
DEALLOCATE c1;;
GO

-- SQL statement 82: Add primary key cb_2014_us_state_500k >>>
ALTER TABLE cb_2014_us_state_500k ADD PRIMARY KEY (gid);
GO

-- SQL statement 83: Add unique key cb_2014_us_state_500k >>>
/*
 * SQL statement name: 	add_unique_key.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: table; e.g. cb_2014_us_nation_5m
 *						2: constraint name; e.g. cb_2014_us_nation_5m_uk
 *						3: fields; e.g. areaid
 *
 * Description:			Add unique key constraint
 * Note:				%% becomes % after substitution
 */
ALTER TABLE cb_2014_us_state_500k ADD CONSTRAINT cb_2014_us_state_500k_uk UNIQUE(areaid);
GO

--
-- Add geometric  data
--

-- SQL statement 85: Add geometry column: geographic centroid >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 *
 * May need to be swapped to geometry to be the same datatype as PostGIS:
 * ALTER TABLE cb_2014_us_state_500k ADD geographic_centroid geometry
 */
ALTER TABLE cb_2014_us_state_500k ADD geographic_centroid geography;
GO

-- SQL statement 86: Add geometry column for original SRID geometry >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 *
 * May need to be swapped to geometry to be the same datatype as PostGIS:
 * ALTER TABLE cb_2014_us_state_500k ADD geom_orig geometry
 */
ALTER TABLE cb_2014_us_state_500k ADD geom_orig geography;
GO

-- SQL statement 87: Add geometry column for zoomlevel: 6 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 *
 * May need to be swapped to geometry to be the same datatype as PostGIS:
 * ALTER TABLE cb_2014_us_state_500k ADD geom_6 geometry
 */
ALTER TABLE cb_2014_us_state_500k ADD geom_6 geography;
GO

-- SQL statement 88: Add geometry column for zoomlevel: 7 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 *
 * May need to be swapped to geometry to be the same datatype as PostGIS:
 * ALTER TABLE cb_2014_us_state_500k ADD geom_7 geometry
 */
ALTER TABLE cb_2014_us_state_500k ADD geom_7 geography;
GO

-- SQL statement 89: Add geometry column for zoomlevel: 8 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 *
 * May need to be swapped to geometry to be the same datatype as PostGIS:
 * ALTER TABLE cb_2014_us_state_500k ADD geom_8 geometry
 */
ALTER TABLE cb_2014_us_state_500k ADD geom_8 geography;
GO

-- SQL statement 90: Add geometry column for zoomlevel: 9 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 *
 * May need to be swapped to geometry to be the same datatype as PostGIS:
 * ALTER TABLE cb_2014_us_state_500k ADD geom_9 geometry
 */
ALTER TABLE cb_2014_us_state_500k ADD geom_9 geography;
GO

-- SQL statement 91: Add geometry column for zoomlevel: 10 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 *
 * May need to be swapped to geometry to be the same datatype as PostGIS:
 * ALTER TABLE cb_2014_us_state_500k ADD geom_10 geometry
 */
ALTER TABLE cb_2014_us_state_500k ADD geom_10 geography;
GO

-- SQL statement 92: Add geometry column for zoomlevel: 11 >>>
/*
 * SQL statement name: 	add_geometry_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: Table name; e.g. cb_2014_us_county_500k
 *						2: column name; e.g. geographic_centroid
 *						3: Column SRID; e.g. 4326
 *						4: Spatial geometry type: e.g. POINT, MULTIPOLYGON
 *
 * Description:			Add geometry column to table
 * Note:				%% becomes % after substitution
 *
 * May need to be swapped to geometry to be the same datatype as PostGIS:
 * ALTER TABLE cb_2014_us_state_500k ADD geom_11 geometry
 */
ALTER TABLE cb_2014_us_state_500k ADD geom_11 geography;
GO

-- SQL statement 93: Update geographic centroid, geometry columns, handle polygons and mutlipolygons, convert highest zoomlevel to original SRID >>>
UPDATE cb_2014_us_state_500k
   SET geographic_centroid = geography::STGeomFromText(geographic_centroid_wkt, 4326),
       geom_6 = geography::STGeomFromText(wkt_6, 4326).MakeValid(),
       geom_7 = geography::STGeomFromText(wkt_7, 4326).MakeValid(),
       geom_8 = geography::STGeomFromText(wkt_8, 4326).MakeValid(),
       geom_9 = geography::STGeomFromText(wkt_9, 4326).MakeValid(),
       geom_10 = geography::STGeomFromText(wkt_10, 4326).MakeValid(),
       geom_11 = geography::STGeomFromText(wkt_11, 4326).MakeValid(),
       geom_orig = /* geography::STTransform(geography::STGeomFromText(wkt_11, 4326).MakeValid(), 4269) NOT POSSIBLE */ NULL;
GO

--
-- Test geometry and make valid if required
--

-- SQL statement 95: Check validity of geometry columns >>>
DECLARE c1 CURSOR FOR
SELECT areaname,
       6 AS geolevel,
       geom_6.IsValidDetailed() AS reason
  FROM cb_2014_us_state_500k
 WHERE geom_6.STIsValid() = 0
UNION
SELECT areaname,
       7 AS geolevel,
       geom_7.IsValidDetailed() AS reason
  FROM cb_2014_us_state_500k
 WHERE geom_7.STIsValid() = 0
UNION
SELECT areaname,
       8 AS geolevel,
       geom_8.IsValidDetailed() AS reason
  FROM cb_2014_us_state_500k
 WHERE geom_8.STIsValid() = 0
UNION
SELECT areaname,
       9 AS geolevel,
       geom_9.IsValidDetailed() AS reason
  FROM cb_2014_us_state_500k
 WHERE geom_9.STIsValid() = 0
UNION
SELECT areaname,
       10 AS geolevel,
       geom_10.IsValidDetailed() AS reason
  FROM cb_2014_us_state_500k
 WHERE geom_10.STIsValid() = 0
UNION
SELECT areaname,
       11 AS geolevel,
       geom_11.IsValidDetailed() AS reason
  FROM cb_2014_us_state_500k
 WHERE geom_11.STIsValid() = 0
ORDER BY 1, 2;
DECLARE @areaname AS VARCHAR(30);
DECLARE @geolevel AS int;
DECLARE @reason AS VARCHAR(90);
DECLARE @nrows AS int;
SET @nrows=0;
OPEN c1;
FETCH NEXT FROM c1 INTO @areaname, @geolevel, @reason;
WHILE @@FETCH_STATUS = 0
BEGIN
		SET @nrows+=1;
	    PRINT 'Area: ' + @areaname + ', geolevel: ' + CAST(@geolevel AS VARCHAR) + ': ' +RTRIM(@reason);
       FETCH NEXT FROM c1 INTO @areaname, @geolevel, @reason;
END
IF @nrows = 0
	PRINT 'Table: cb_2014_us_state_500k no invalid geometry check OK';
ELSE
	RAISERROR('Table: cb_2014_us_state_500k no invalid geometry check FAILED: %i invalid', 16, 1, @nrows);
CLOSE c1;
DEALLOCATE c1;
GO

--
-- Make all polygons right handed
--

-- SQL statement 97: Make all polygons right handed for zoomlevel: 6 >>>
/*
 * SQL statement name: 	force_rhr.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Create insert statement into hierarchy table
 * Note:				%% becomes % after substitution
 * 						c.geom_6.STUnion(geom_6.STStartPoint()) is also possible instead of c.geom_6.ReorientObject()
 */
WITH a AS (
	SELECT gid, geom_6,
		   CAST(area_km2 AS NUMERIC(21,6)) AS area_km2,
		   CAST((geom_6.STArea()/(1000*1000)) AS NUMERIC(21,6)) AS area_km2_calc
	  FROM cb_2014_us_state_500k
), b AS (
	SELECT a.gid,
	       a.geom_6,
           a.area_km2,
	       a.area_km2_calc,
          CASE WHEN a.area_km2 > 0 THEN CAST(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2) AS NUMERIC(21,6))
				WHEN a.area_km2 = a.area_km2_calc THEN 0
	        	ELSE NULL
	   	   END AS pct_km2_diff 
  FROM a
)
UPDATE cb_2014_us_state_500k
   SET geom_6 = c.geom_6.ReorientObject()
  FROM cb_2014_us_state_500k c
 JOIN b ON b.gid = c.gid
 WHERE b.pct_km2_diff > 200 /* Threshold test */;
GO

-- SQL statement 98: Make all polygons right handed for zoomlevel: 7 >>>
/*
 * SQL statement name: 	force_rhr.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Create insert statement into hierarchy table
 * Note:				%% becomes % after substitution
 * 						c.geom_7.STUnion(geom_7.STStartPoint()) is also possible instead of c.geom_7.ReorientObject()
 */
WITH a AS (
	SELECT gid, geom_7,
		   CAST(area_km2 AS NUMERIC(21,6)) AS area_km2,
		   CAST((geom_7.STArea()/(1000*1000)) AS NUMERIC(21,6)) AS area_km2_calc
	  FROM cb_2014_us_state_500k
), b AS (
	SELECT a.gid,
	       a.geom_7,
           a.area_km2,
	       a.area_km2_calc,
          CASE WHEN a.area_km2 > 0 THEN CAST(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2) AS NUMERIC(21,6))
				WHEN a.area_km2 = a.area_km2_calc THEN 0
	        	ELSE NULL
	   	   END AS pct_km2_diff 
  FROM a
)
UPDATE cb_2014_us_state_500k
   SET geom_7 = c.geom_7.ReorientObject()
  FROM cb_2014_us_state_500k c
 JOIN b ON b.gid = c.gid
 WHERE b.pct_km2_diff > 200 /* Threshold test */;
GO

-- SQL statement 99: Make all polygons right handed for zoomlevel: 8 >>>
/*
 * SQL statement name: 	force_rhr.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Create insert statement into hierarchy table
 * Note:				%% becomes % after substitution
 * 						c.geom_8.STUnion(geom_8.STStartPoint()) is also possible instead of c.geom_8.ReorientObject()
 */
WITH a AS (
	SELECT gid, geom_8,
		   CAST(area_km2 AS NUMERIC(21,6)) AS area_km2,
		   CAST((geom_8.STArea()/(1000*1000)) AS NUMERIC(21,6)) AS area_km2_calc
	  FROM cb_2014_us_state_500k
), b AS (
	SELECT a.gid,
	       a.geom_8,
           a.area_km2,
	       a.area_km2_calc,
          CASE WHEN a.area_km2 > 0 THEN CAST(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2) AS NUMERIC(21,6))
				WHEN a.area_km2 = a.area_km2_calc THEN 0
	        	ELSE NULL
	   	   END AS pct_km2_diff 
  FROM a
)
UPDATE cb_2014_us_state_500k
   SET geom_8 = c.geom_8.ReorientObject()
  FROM cb_2014_us_state_500k c
 JOIN b ON b.gid = c.gid
 WHERE b.pct_km2_diff > 200 /* Threshold test */;
GO

-- SQL statement 100: Make all polygons right handed for zoomlevel: 9 >>>
/*
 * SQL statement name: 	force_rhr.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Create insert statement into hierarchy table
 * Note:				%% becomes % after substitution
 * 						c.geom_9.STUnion(geom_9.STStartPoint()) is also possible instead of c.geom_9.ReorientObject()
 */
WITH a AS (
	SELECT gid, geom_9,
		   CAST(area_km2 AS NUMERIC(21,6)) AS area_km2,
		   CAST((geom_9.STArea()/(1000*1000)) AS NUMERIC(21,6)) AS area_km2_calc
	  FROM cb_2014_us_state_500k
), b AS (
	SELECT a.gid,
	       a.geom_9,
           a.area_km2,
	       a.area_km2_calc,
          CASE WHEN a.area_km2 > 0 THEN CAST(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2) AS NUMERIC(21,6))
				WHEN a.area_km2 = a.area_km2_calc THEN 0
	        	ELSE NULL
	   	   END AS pct_km2_diff 
  FROM a
)
UPDATE cb_2014_us_state_500k
   SET geom_9 = c.geom_9.ReorientObject()
  FROM cb_2014_us_state_500k c
 JOIN b ON b.gid = c.gid
 WHERE b.pct_km2_diff > 200 /* Threshold test */;
GO

-- SQL statement 101: Make all polygons right handed for zoomlevel: 10 >>>
/*
 * SQL statement name: 	force_rhr.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Create insert statement into hierarchy table
 * Note:				%% becomes % after substitution
 * 						c.geom_10.STUnion(geom_10.STStartPoint()) is also possible instead of c.geom_10.ReorientObject()
 */
WITH a AS (
	SELECT gid, geom_10,
		   CAST(area_km2 AS NUMERIC(21,6)) AS area_km2,
		   CAST((geom_10.STArea()/(1000*1000)) AS NUMERIC(21,6)) AS area_km2_calc
	  FROM cb_2014_us_state_500k
), b AS (
	SELECT a.gid,
	       a.geom_10,
           a.area_km2,
	       a.area_km2_calc,
          CASE WHEN a.area_km2 > 0 THEN CAST(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2) AS NUMERIC(21,6))
				WHEN a.area_km2 = a.area_km2_calc THEN 0
	        	ELSE NULL
	   	   END AS pct_km2_diff 
  FROM a
)
UPDATE cb_2014_us_state_500k
   SET geom_10 = c.geom_10.ReorientObject()
  FROM cb_2014_us_state_500k c
 JOIN b ON b.gid = c.gid
 WHERE b.pct_km2_diff > 200 /* Threshold test */;
GO

-- SQL statement 102: Make all polygons right handed for zoomlevel: 11 >>>
/*
 * SQL statement name: 	force_rhr.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Create insert statement into hierarchy table
 * Note:				%% becomes % after substitution
 * 						c.geom_11.STUnion(geom_11.STStartPoint()) is also possible instead of c.geom_11.ReorientObject()
 */
WITH a AS (
	SELECT gid, geom_11,
		   CAST(area_km2 AS NUMERIC(21,6)) AS area_km2,
		   CAST((geom_11.STArea()/(1000*1000)) AS NUMERIC(21,6)) AS area_km2_calc
	  FROM cb_2014_us_state_500k
), b AS (
	SELECT a.gid,
	       a.geom_11,
           a.area_km2,
	       a.area_km2_calc,
          CASE WHEN a.area_km2 > 0 THEN CAST(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2) AS NUMERIC(21,6))
				WHEN a.area_km2 = a.area_km2_calc THEN 0
	        	ELSE NULL
	   	   END AS pct_km2_diff 
  FROM a
)
UPDATE cb_2014_us_state_500k
   SET geom_11 = c.geom_11.ReorientObject()
  FROM cb_2014_us_state_500k c
 JOIN b ON b.gid = c.gid
 WHERE b.pct_km2_diff > 200 /* Threshold test */;
GO

--
-- Test Turf and DB areas agree to within 1%
--

-- SQL statement 104: Test Turf and DB areas agree to within 1% (Postgres)/5% (SQL server) >>>
DECLARE c1 CURSOR FOR
/*
 * SQL statement name: 	area_check.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Check Turf araa (area_km2) compared to SQL Server calculated area (area_km2_calc)
 *						Allow for 5% error
 *						Ignore small areas <= 10 km2
 * Note:				%% becomes % after substitution
 */
	WITH a AS (
		SELECT areaname,
			   CAST(area_km2 AS NUMERIC(15,2)) AS area_km2,
			   CAST((geom_11.STArea()/(1000*1000)) AS NUMERIC(15,2)) AS area_km2_calc
		  FROM cb_2014_us_state_500k
	), b AS (
	SELECT SUBSTRING(a.areaname, 1, 30) AS areaname,
		   a.area_km2,
		   a.area_km2_calc,
		   CASE WHEN a.area_km2 > 0 THEN CAST(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2) AS NUMERIC(15,2))
				WHEN a.area_km2 = a.area_km2_calc THEN 0
				ELSE NULL
		   END AS pct_km2_diff
	  FROM a
	)
	SELECT b.areaname, b.area_km2, b.area_km2_calc, b.pct_km2_diff
	  FROM b
	 WHERE b.pct_km2_diff > 5 /* Allow for 5% error */
	   AND b.area_km2_calc > 10 /* Ignore small areas <= 10 km2 */;
DECLARE @areaname AS VARCHAR(30);
DECLARE @area_km2 AS NUMERIC(15,2);
DECLARE @area_km2_calc AS NUMERIC(15,2);
DECLARE @pct_km2_diff AS NUMERIC(15,2);
DECLARE @nrows AS int;
SET @nrows=0;
OPEN c1;
FETCH NEXT FROM c1 INTO @areaname, @area_km2, @area_km2_calc, @pct_km2_diff;
WHILE @@FETCH_STATUS = 0
BEGIN
		SET @nrows+=1;
		PRINT 'Area: ' + @areaname + ', area km2: ' + CAST(@area_km2 AS VARCHAR) +  + ', calc: ' +
			CAST(@area_km2_calc AS VARCHAR) + ', diff: ' + CAST(@pct_km2_diff AS VARCHAR);
		FETCH NEXT FROM c1 INTO @areaname, @area_km2, @area_km2_calc, @pct_km2_diff;
END
IF @nrows = 0
	PRINT 'Table: cb_2014_us_state_500k no invalid areas check OK';
ELSE
	RAISERROR('Table: cb_2014_us_state_500k no invalid areas check FAILED: %i invalid', 16, 1, @nrows);
CLOSE c1;
DEALLOCATE c1;
GO

--
-- Create spatial indexes
--

-- SQL statement 106: Index geometry column for zoomlevel: 6 >>>
CREATE SPATIAL INDEX cb_2014_us_state_500k_geom_6_gix ON cb_2014_us_state_500k (geom_6);
GO

-- SQL statement 107: Index geometry column for zoomlevel: 7 >>>
CREATE SPATIAL INDEX cb_2014_us_state_500k_geom_7_gix ON cb_2014_us_state_500k (geom_7);
GO

-- SQL statement 108: Index geometry column for zoomlevel: 8 >>>
CREATE SPATIAL INDEX cb_2014_us_state_500k_geom_8_gix ON cb_2014_us_state_500k (geom_8);
GO

-- SQL statement 109: Index geometry column for zoomlevel: 9 >>>
CREATE SPATIAL INDEX cb_2014_us_state_500k_geom_9_gix ON cb_2014_us_state_500k (geom_9);
GO

-- SQL statement 110: Index geometry column for zoomlevel: 10 >>>
CREATE SPATIAL INDEX cb_2014_us_state_500k_geom_10_gix ON cb_2014_us_state_500k (geom_10);
GO

-- SQL statement 111: Index geometry column for zoomlevel: 11 >>>
CREATE SPATIAL INDEX cb_2014_us_state_500k_geom_11_gix ON cb_2014_us_state_500k (geom_11);
GO

-- SQL statement 112: Index geometry column for original SRID geometry >>>
CREATE SPATIAL INDEX cb_2014_us_state_500k_geom_orig_gix ON cb_2014_us_state_500k (geom_orig);
GO

--
-- Reports
--

-- SQL statement 114: Areas and centroids report >>>
/*
 * SQL statement name: 	area_centroid_report.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: geometry column; e.g. geom_11
 *						2: table name; e.g. cb_2014_us_county_500k
 *
 * Description:			Area and centroids report
 * Note:				% becomes % after substitution
 */
WITH a AS (
	SELECT areaname, geom_11,
		   CAST(area_km2 AS NUMERIC(15,2)) AS area_km2,
		   CAST((geom_11.STArea()/(1000*1000)) AS NUMERIC(15,2)) AS area_km2_calc,
		   CONCAT(
				CAST(CAST(geographic_centroid.Long AS NUMERIC(15,7)) AS VARCHAR(30)),
				',',
				CAST(CAST(geographic_centroid.Lat AS NUMERIC(15,7)) AS VARCHAR(30))
				) AS geographic_centroid,
		   CONCAT(
				CAST(CAST(geom_11.EnvelopeCenter().Long AS NUMERIC(15,7)) AS VARCHAR(30)),
				',',
				CAST(CAST(geom_11.EnvelopeCenter().Lat AS NUMERIC(15,7)) AS VARCHAR(30))
				) AS geographic_centroid_calc,
		   CAST((geom_11.EnvelopeCenter().STDistance(geographic_centroid))/1000 AS VARCHAR(30)) AS centroid_diff_km,
		   ROW_NUMBER() OVER (ORDER BY areaname) as nrow
	  FROM cb_2014_us_state_500k
)
SELECT SUBSTRING(a.areaname, 1, 30) AS areaname,
       a.area_km2,
	   a.area_km2_calc,
	   CAST(100*(ABS(a.area_km2 - a.area_km2_calc)/area_km2) AS NUMERIC(15,2)) AS pct_km2_diff,
	   a.geographic_centroid,
       a.geographic_centroid_calc,
	   a.centroid_diff_km
  FROM a
 WHERE nrow <= 100
 ORDER BY 1 ;
GO

--
-- Geography meta data
--

-- SQL statement 116: Drop table geography_cb_2014_us_500k >>>
IF OBJECT_ID('geography_cb_2014_us_500k', 'U') IS NOT NULL DROP TABLE geography_cb_2014_us_500k;
GO

-- SQL statement 117: Create geography meta data table >>>
/*
 * SQL statement name: 	create_geography_table.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: table; e.g. geography_cb_2014_us_county_500k
 *
 * Description:			Create geography table
 * Note:				%% becomes % after substitution
 */
CREATE TABLE geography_cb_2014_us_500k (
       geography               VARCHAR(50)  NOT NULL,
       description             VARCHAR(250) NOT NULL,
       hierarchytable          VARCHAR(30)  NOT NULL,
       srid                    INTEGER      NULL DEFAULT 0,
       defaultcomparea         VARCHAR(30)  NULL,
       defaultstudyarea        VARCHAR(30)  NULL,
       CONSTRAINT geography_cb_2014_us_500k_pk PRIMARY KEY(geography)
	);
GO

-- SQL statement 118: Comment geography meta data table >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_table.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'Hierarchial geographies. Usually based on Census geography',
   'user', @CurrentUser,   
   'table', 'geography_cb_2014_us_500k';
GO

-- SQL statement 119: Populate geography meta data table >>>
/*
 * SQL statement name: 	insert_geography.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: table; e.g. geography_cb_2014_us_county_500k
 *						2: geography; e.g. cb_2014_us_500k
 *						3: geography description; e.g. "United states to county level"
 *						4: hierarchytable; e.g. hierarchy_cb_2014_us_500k
 * 						5: SRID; e.g. 4269
 *						6: Default comparision area
 *						7: Default study area
 *
 * Description:			Insert into geography table
 * Note:				%% becomes % after substitution
 */
INSERT INTO geography_cb_2014_us_500k (
geography, description, hierarchytable, srid, defaultcomparea, defaultstudyarea)
SELECT 'cb_2014_us_500k' AS geography,
       'Description of: cb_2014_us_nation_5m' AS description,
       'hierarchy_cb_2014_us_500k' AS hierarchytable,
       4269 AS srid,
       'GEOID' AS defaultcomparea,
       'STATENS' AS defaultstudyarea;
GO

-- SQL statement 120: Comment geography meta data column >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'Geography name',
   'user', @CurrentUser,   
   'table', 'geography_cb_2014_us_500k',
   'column', 'geography';
GO

-- SQL statement 121: Comment geography meta data column >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'Description',
   'user', @CurrentUser,   
   'table', 'geography_cb_2014_us_500k',
   'column', 'description';
GO

-- SQL statement 122: Comment geography meta data column >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'Hierarchy table',
   'user', @CurrentUser,   
   'table', 'geography_cb_2014_us_500k',
   'column', 'hierarchytable';
GO

-- SQL statement 123: Comment geography meta data column >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'Projection SRID',
   'user', @CurrentUser,   
   'table', 'geography_cb_2014_us_500k',
   'column', 'srid';
GO

-- SQL statement 124: Comment geography meta data column >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'Default comparison area: lowest resolution geolevel',
   'user', @CurrentUser,   
   'table', 'geography_cb_2014_us_500k',
   'column', 'defaultcomparea';
GO

-- SQL statement 125: Comment geography meta data column >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'Default study area: highest resolution geolevel',
   'user', @CurrentUser,   
   'table', 'geography_cb_2014_us_500k',
   'column', 'defaultstudyarea';
GO

--
-- Geolevels meta data
--

-- SQL statement 127: Drop table geolevels_cb_2014_us_500k >>>
IF OBJECT_ID('geolevels_cb_2014_us_500k', 'U') IS NOT NULL DROP TABLE geolevels_cb_2014_us_500k;
GO

-- SQL statement 128: Create geolevels meta data table >>>
CREATE TABLE geolevels_cb_2014_us_500k (
       geography                       VARCHAR(50)  NOT NULL,
       geolevel_name                   VARCHAR(30)  NOT NULL,
       geolevel_id			        	integer	     NOT NULL,
       description                     VARCHAR(250) NOT NULL,
       lookup_table                    VARCHAR(30)  NOT NULL,
       lookup_desc_column              VARCHAR(30)  NOT NULL,
       shapefile                       VARCHAR(512) NOT NULL,
       shapefile_table                 VARCHAR(30)  NULL,
       shapefile_area_id_column        VARCHAR(30)  NOT NULL,
       shapefile_desc_column           VARCHAR(30)  NULL,
       resolution                      integer      NULL,
       comparea                        integer      NULL,
       listing                         integer      NULL,
       CONSTRAINT geolevels_cb_2014_us_500k_pk PRIMARY KEY(geography, geolevel_name)
);
GO

-- SQL statement 129: Comment geolevels meta data table >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_table.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'Geolevels: hierarchy of level within a geography',
   'user', @CurrentUser,   
   'table', 'geolevels_cb_2014_us_500k';
GO

-- SQL statement 130: Comment geolevels meta data column >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'Geography (e.g EW2001)',
   'user', @CurrentUser,   
   'table', 'geolevels_cb_2014_us_500k',
   'column', 'geography';
GO

-- SQL statement 131: Comment geolevels meta data column >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'Name of geolevel. This will be a column name in the numerator/denominator tables',
   'user', @CurrentUser,   
   'table', 'geolevels_cb_2014_us_500k',
   'column', 'geolevel_name';
GO

-- SQL statement 132: Comment geolevels meta data column >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'ID for ordering (1=lowest resolution). Up to 99 supported.',
   'user', @CurrentUser,   
   'table', 'geolevels_cb_2014_us_500k',
   'column', 'geolevel_id';
GO

-- SQL statement 133: Comment geolevels meta data column >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'Description',
   'user', @CurrentUser,   
   'table', 'geolevels_cb_2014_us_500k',
   'column', 'description';
GO

-- SQL statement 134: Comment geolevels meta data column >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'Lookup table name. This is used to translate codes to the common names, e.g a LADUA of 00BK is "Westminster"',
   'user', @CurrentUser,   
   'table', 'geolevels_cb_2014_us_500k',
   'column', 'lookup_table';
GO

-- SQL statement 135: Comment geolevels meta data column >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'Lookup table description column name.',
   'user', @CurrentUser,   
   'table', 'geolevels_cb_2014_us_500k',
   'column', 'lookup_desc_column';
GO

-- SQL statement 136: Comment geolevels meta data column >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'Location of the GIS shape file. NULL if PostGress/PostGIS used. Can also use SHAPEFILE_GEOMETRY instead',
   'user', @CurrentUser,   
   'table', 'geolevels_cb_2014_us_500k',
   'column', 'shapefile';
GO

-- SQL statement 137: Comment geolevels meta data column >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'Table containing GIS shape file data.',
   'user', @CurrentUser,   
   'table', 'geolevels_cb_2014_us_500k',
   'column', 'shapefile_table';
GO

-- SQL statement 138: Comment geolevels meta data column >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'Column containing the AREA_IDs in SHAPEFILE_TABLE',
   'user', @CurrentUser,   
   'table', 'geolevels_cb_2014_us_500k',
   'column', 'shapefile_area_id_column';
GO

-- SQL statement 139: Comment geolevels meta data column >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'Column containing the AREA_ID descriptions in SHAPEFILE_TABLE',
   'user', @CurrentUser,   
   'table', 'geolevels_cb_2014_us_500k',
   'column', 'shapefile_desc_column';
GO

-- SQL statement 140: Comment geolevels meta data column >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'Can use a map for selection at this resolution (0/1)',
   'user', @CurrentUser,   
   'table', 'geolevels_cb_2014_us_500k',
   'column', 'resolution';
GO

-- SQL statement 141: Comment geolevels meta data column >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'Able to be used as a comparison area (0/1)',
   'user', @CurrentUser,   
   'table', 'geolevels_cb_2014_us_500k',
   'column', 'comparea';
GO

-- SQL statement 142: Comment geolevels meta data column >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_column.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: column; e.g. geolevel_name
 *						3: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'Able to be used in a disease map listing (0/1)',
   'user', @CurrentUser,   
   'table', 'geolevels_cb_2014_us_500k',
   'column', 'listing';
GO

-- SQL statement 143: Insert geolevels meta data for: cb_2014_us_county_500k >>>
/*
 * SQL statement name: 	insert_geolevel.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: geography; e.g. cb_2014_us_500k
 *						3: Geolevel name; e.g. cb_2014_us_county_500k
 *						4: Geolevel id; e.g. 3
 *						5: Geolevel description; e.g. "The State-County at a scale of 1:500,000"
 *						6: lookup table; e.g. lookup_cb_2014_us_county_500k
 * 						7: shapefile; e.g. cb_2014_us_county_500k.shp
 *						8: shapefile table; e.g. cb_2014_us_county_500k
 *
 * Description:			Insert into geography table
 * Note:				%% becomes % after substitution
 */
INSERT INTO geolevels_cb_2014_us_500k (
   geography, geolevel_name, geolevel_id, description, lookup_table,
   lookup_desc_column, shapefile, shapefile_table, shapefile_area_id_column, shapefile_desc_column,
   resolution, comparea, listing)
SELECT 'cb_2014_us_500k' AS geography,
       'cb_2014_us_county_500k' AS geolevel_name,
       3 AS geolevel_id,
       'The State-County at a scale of 1:500,000' AS description,
       'lookup_cb_2014_us_county_500k' AS lookup_table,
       'areaname' AS lookup_desc_column,
       'cb_2014_us_county_500k.shp.shp' AS shapefile,
       'cb_2014_us_county_500k' AS shapefile_table,
       'areaid' AS shapefile_area_id_column,
       'areaname' AS shapefile_desc_column,
       1 AS resolution,
       1 AS comparea,
       1 AS listing;
GO

-- SQL statement 144: Insert geolevels meta data for: cb_2014_us_nation_5m >>>
/*
 * SQL statement name: 	insert_geolevel.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: geography; e.g. cb_2014_us_500k
 *						3: Geolevel name; e.g. cb_2014_us_county_500k
 *						4: Geolevel id; e.g. 3
 *						5: Geolevel description; e.g. "The State-County at a scale of 1:500,000"
 *						6: lookup table; e.g. lookup_cb_2014_us_county_500k
 * 						7: shapefile; e.g. cb_2014_us_county_500k.shp
 *						8: shapefile table; e.g. cb_2014_us_county_500k
 *
 * Description:			Insert into geography table
 * Note:				%% becomes % after substitution
 */
INSERT INTO geolevels_cb_2014_us_500k (
   geography, geolevel_name, geolevel_id, description, lookup_table,
   lookup_desc_column, shapefile, shapefile_table, shapefile_area_id_column, shapefile_desc_column,
   resolution, comparea, listing)
SELECT 'cb_2014_us_500k' AS geography,
       'cb_2014_us_nation_5m' AS geolevel_name,
       1 AS geolevel_id,
       'Theat a scale of 1:5,000,000' AS description,
       'lookup_cb_2014_us_nation_5m' AS lookup_table,
       'areaname' AS lookup_desc_column,
       'cb_2014_us_nation_5m.shp.shp' AS shapefile,
       'cb_2014_us_nation_5m' AS shapefile_table,
       'areaid' AS shapefile_area_id_column,
       'areaname' AS shapefile_desc_column,
       1 AS resolution,
       1 AS comparea,
       1 AS listing;
GO

-- SQL statement 145: Insert geolevels meta data for: cb_2014_us_state_500k >>>
/*
 * SQL statement name: 	insert_geolevel.sql
 * Type:				Common SQL statement
 * Parameters:
 *						1: table; e.g. geolevels_cb_2014_us_county_500k
 *						2: geography; e.g. cb_2014_us_500k
 *						3: Geolevel name; e.g. cb_2014_us_county_500k
 *						4: Geolevel id; e.g. 3
 *						5: Geolevel description; e.g. "The State-County at a scale of 1:500,000"
 *						6: lookup table; e.g. lookup_cb_2014_us_county_500k
 * 						7: shapefile; e.g. cb_2014_us_county_500k.shp
 *						8: shapefile table; e.g. cb_2014_us_county_500k
 *
 * Description:			Insert into geography table
 * Note:				%% becomes % after substitution
 */
INSERT INTO geolevels_cb_2014_us_500k (
   geography, geolevel_name, geolevel_id, description, lookup_table,
   lookup_desc_column, shapefile, shapefile_table, shapefile_area_id_column, shapefile_desc_column,
   resolution, comparea, listing)
SELECT 'cb_2014_us_500k' AS geography,
       'cb_2014_us_state_500k' AS geolevel_name,
       2 AS geolevel_id,
       'The State at a scale of 1:500,000' AS description,
       'lookup_cb_2014_us_state_500k' AS lookup_table,
       'areaname' AS lookup_desc_column,
       'cb_2014_us_state_500k.shp.shp' AS shapefile,
       'cb_2014_us_state_500k' AS shapefile_table,
       'areaid' AS shapefile_area_id_column,
       'areaname' AS shapefile_desc_column,
       1 AS resolution,
       1 AS comparea,
       1 AS listing;
GO

--
-- Geolevels lookup tables
--

-- SQL statement 147: Drop table lookup_cb_2014_us_county_500k >>>
IF OBJECT_ID('lookup_cb_2014_us_county_500k', 'U') IS NOT NULL DROP TABLE lookup_cb_2014_us_county_500k;
GO

-- SQL statement 148: Create table lookup_cb_2014_us_county_500k >>>
CREATE TABLE lookup_cb_2014_us_county_500k (
	cb_2014_us_county_500k			VARCHAR(100)  NOT NULL,
	areaname	VARCHAR(1000)
);
GO

-- SQL statement 149: Insert table lookup_cb_2014_us_county_500k >>>
INSERT INTO lookup_cb_2014_us_county_500k(cb_2014_us_county_500k, areaname)
SELECT areaid, areaname
  FROM cb_2014_us_county_500k
 ORDER BY 1;
GO

-- SQL statement 150: Add primary key lookup_cb_2014_us_county_500k >>>
ALTER TABLE lookup_cb_2014_us_county_500k ADD PRIMARY KEY (cb_2014_us_county_500k);
GO

-- SQL statement 151: Comment table lookup_cb_2014_us_county_500k >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_table.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'Lookup table for The State-County at a scale of 1:500,000',
   'user', @CurrentUser,   
   'table', 'lookup_cb_2014_us_county_500k';
GO

-- SQL statement 152: Drop table lookup_cb_2014_us_nation_5m >>>
IF OBJECT_ID('lookup_cb_2014_us_nation_5m', 'U') IS NOT NULL DROP TABLE lookup_cb_2014_us_nation_5m;
GO

-- SQL statement 153: Create table lookup_cb_2014_us_nation_5m >>>
CREATE TABLE lookup_cb_2014_us_nation_5m (
	cb_2014_us_nation_5m			VARCHAR(100)  NOT NULL,
	areaname	VARCHAR(1000)
);
GO

-- SQL statement 154: Insert table lookup_cb_2014_us_nation_5m >>>
INSERT INTO lookup_cb_2014_us_nation_5m(cb_2014_us_nation_5m, areaname)
SELECT areaid, areaname
  FROM cb_2014_us_nation_5m
 ORDER BY 1;
GO

-- SQL statement 155: Add primary key lookup_cb_2014_us_nation_5m >>>
ALTER TABLE lookup_cb_2014_us_nation_5m ADD PRIMARY KEY (cb_2014_us_nation_5m);
GO

-- SQL statement 156: Comment table lookup_cb_2014_us_nation_5m >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_table.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'Lookup table for Theat a scale of 1:5,000,000',
   'user', @CurrentUser,   
   'table', 'lookup_cb_2014_us_nation_5m';
GO

-- SQL statement 157: Drop table lookup_cb_2014_us_state_500k >>>
IF OBJECT_ID('lookup_cb_2014_us_state_500k', 'U') IS NOT NULL DROP TABLE lookup_cb_2014_us_state_500k;
GO

-- SQL statement 158: Create table lookup_cb_2014_us_state_500k >>>
CREATE TABLE lookup_cb_2014_us_state_500k (
	cb_2014_us_state_500k			VARCHAR(100)  NOT NULL,
	areaname	VARCHAR(1000)
);
GO

-- SQL statement 159: Insert table lookup_cb_2014_us_state_500k >>>
INSERT INTO lookup_cb_2014_us_state_500k(cb_2014_us_state_500k, areaname)
SELECT areaid, areaname
  FROM cb_2014_us_state_500k
 ORDER BY 1;
GO

-- SQL statement 160: Add primary key lookup_cb_2014_us_state_500k >>>
ALTER TABLE lookup_cb_2014_us_state_500k ADD PRIMARY KEY (cb_2014_us_state_500k);
GO

-- SQL statement 161: Comment table lookup_cb_2014_us_state_500k >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_table.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'Lookup table for The State at a scale of 1:500,000',
   'user', @CurrentUser,   
   'table', 'lookup_cb_2014_us_state_500k';
GO

--
-- Hierarchy table
--

-- SQL statement 163: Drop table hierarchy_cb_2014_us_500k >>>
IF OBJECT_ID('hierarchy_cb_2014_us_500k', 'U') IS NOT NULL DROP TABLE hierarchy_cb_2014_us_500k;
GO

-- SQL statement 164: Create table hierarchy_cb_2014_us_500k >>>
CREATE TABLE hierarchy_cb_2014_us_500k (
	cb_2014_us_county_500k	VARCHAR(100)  NOT NULL,
	cb_2014_us_nation_5m	VARCHAR(100)  NOT NULL,
	cb_2014_us_state_500k	VARCHAR(100)  NOT NULL);
GO

-- SQL statement 165: Add primary key hierarchy_cb_2014_us_500k >>>
ALTER TABLE hierarchy_cb_2014_us_500k ADD PRIMARY KEY (cb_2014_us_county_500k);
GO

-- SQL statement 166: Add index key hierarchy_cb_2014_us_500k_cb_2014_us_state_500k >>>
CREATE INDEX hierarchy_cb_2014_us_500k_cb_2014_us_state_500k ON hierarchy_cb_2014_us_500k (cb_2014_us_state_500k);
GO

-- SQL statement 167: Comment table: hierarchy_cb_2014_us_500k >>>
DECLARE @CurrentUser sysname /*
 * SQL statement name: 	comment_table.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: table; e.g. cb_2014_us_county_500k
 *						2: comment. Usual rules for comment text in SQK - single 
 *									quotes (') need to be double ('')
 *
 * Description:			Comment table
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'Hierarchy lookup table for Description of: cb_2014_us_nation_5m',
   'user', @CurrentUser,   
   'table', 'hierarchy_cb_2014_us_500k';
GO

-- SQL statement 168: Create function check_hierarchy_cb_2014_us_500k >>>
IF OBJECT_ID(N'check_hierarchy_cb_2014_us_500k', N'P') IS NOT NULL  
    DROP PROCEDURE check_hierarchy_cb_2014_us_500k;  
GO
SELECT name, type, type_desc FROM sys.objects WHERE name = 'check_hierarchy_cb_2014_us_500k';
GO

CREATE PROCEDURE check_hierarchy_cb_2014_us_500k(
	@l_geography 		VARCHAR(30), 
	@l_hierarchytable 	VARCHAR(200), 
	@l_type 			VARCHAR(30),
	@error_count 		INTEGER OUTPUT)
AS
/*
 * SQL statement name: 	check_hierarchy_function.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: function name; e.g. check_hierarchy_cb_2014_us_500k
 *
 * Description:			Create hierarchy check function
 * Note:				% becomes % after substitution
 */
 
/*
Function: 		check_hierarchy_cb_2014_us_500k()
Parameters:		Geography, hierarchy table, type: 'missing', 'spurious additional' or 'multiple hierarchy'
Returns:		Nothing
Description:	Diff geography hierarchy table using dynamic method 4
				Also tests the hierarchy, i.e. all a higher resolutuion is contained by one of the next higher and so on

WITH /- multiple hierarchy -/ a2 AS (
        SELECT COUNT(*) AS cb_2014_us_state_500k_total
          FROM (
                SELECT cb_2014_us_state_500k, COUNT(DISTINCT(cb_2014_us_nation_5m)) AS total
                  FROM hierarchy_cb_2014_us_500k
                 GROUP BY cb_2014_us_state_500k
                HAVING COUNT(DISTINCT(cb_2014_us_nation_5m)) > 1) as2
), a3 AS (
        SELECT COUNT(*) AS cb_2014_us_county_500k_total
          FROM (
                SELECT cb_2014_us_county_500k, COUNT(DISTINCT(cb_2014_us_state_500k)) AS total
                  FROM hierarchy_cb_2014_us_500k
                 GROUP BY cb_2014_us_county_500k
                HAVING COUNT(DISTINCT(cb_2014_us_state_500k)) > 1) as3
)
SELECT CAST('cb_2014_us_state_500k' AS VARCHAR) AS col,
			a2.cb_2014_us_state_500k_total AS val
  FROM a2
UNION
SELECT CAST('cb_2014_us_county_500k' AS VARCHAR) AS col,
			a3.cb_2014_us_county_500k_total AS val
  FROM a3;
  
*/
BEGIN 
	DECLARE c2 CURSOR FOR
		SELECT geolevel_id, geolevel_name, lookup_table		
		  FROM geolevels_cb_2014_us_500k
		 WHERE geography = @l_geography
		 ORDER BY geolevel_id;
--
	DECLARE @sql_stmt 				AS NVARCHAR(max)='XXX';
	DECLARE @i 						AS INTEGER=0;	
--
	DECLARE @crlf					AS VARCHAR(2)=CHAR(10)+CHAR(13);
	DECLARE @tab					AS VARCHAR(1)=CHAR(9);
--
	DECLARE @geolevel_id 			AS INTEGER;
	DECLARE @geolevel_name		 	AS VARCHAR(200);
	DECLARE @lookup_table 			AS VARCHAR(200);
	DECLARE @previous_geolevel_name AS VARCHAR(200);
--
	SET @error_count=0;
	SET @sql_stmt='WITH /* ' + @l_type + ' */ ';
--
	OPEN c2;
	FETCH NEXT FROM c2 INTO @geolevel_id, @geolevel_name, @lookup_table;
	WHILE @@FETCH_STATUS = 0
	BEGIN
		SET @i+=1;
--
		IF @l_type = 'multiple hierarchy' 
			BEGIN
				IF @i = 1 
					noop:
				ELSE IF @i > 2
					SET @sql_stmt+=', ' + 'a' + CAST(@geolevel_id AS VARCHAR) + ' AS (' + @crlf +
							@tab + 'SELECT COUNT(*) AS ' + LOWER(@geolevel_name) + '_total' + @crlf +
							@tab + '  FROM (' + @crlf;
				ELSE
					SET @sql_stmt+='a' + CAST(@geolevel_id AS VARCHAR) + ' AS (' + @crlf +
							@tab + 'SELECT COUNT(*) AS ' + LOWER(@geolevel_name) + '_total' + @crlf +
							@tab + '  FROM (' + @crlf;
			END;
		ELSE
			BEGIN
				IF @i != 1
					SET @sql_stmt+=', ' + 'a' + CAST(@geolevel_id AS VARCHAR) + ' AS (' + @crlf;
				ELSE
					SET @sql_stmt+='a' + CAST(@geolevel_id AS VARCHAR) + ' AS (' + @crlf;
				SET @sql_stmt+=@tab + 'SELECT COUNT(*) AS ' + LOWER(@geolevel_name) + '_total' + @crlf +
					@tab + '  FROM (' + @crlf;
			END;
--
		IF @l_type = 'missing'
			SET @sql_stmt+=@tab + @tab + 'SELECT ' + LOWER(@geolevel_name) + 
				' FROM ' + LOWER(@l_hierarchytable) + @crlf +
				@tab + @tab + 'EXCEPT' + @crlf +
				@tab + @tab + 'SELECT ' + LOWER(@geolevel_name) + ' FROM ' + LOWER(@lookup_table) + 
				') as' + CAST(@geolevel_id AS VARCHAR) + ')' + @crlf;
		ELSE IF @l_type = 'spurious additional' 
			SET @sql_stmt+=@tab + @tab + 'SELECT ' + LOWER(@geolevel_name) + 
				' FROM ' + LOWER(@lookup_table) + @crlf +
				@tab + @tab + 'EXCEPT' + @crlf +
				@tab + @tab + 'SELECT ' + LOWER(@geolevel_name) + ' FROM ' + LOWER(@l_hierarchytable) + 
				') as' + CAST(@geolevel_id AS VARCHAR) + ')' + @crlf;
		ELSE IF @l_type = 'multiple hierarchy' 
			BEGIN
				IF @previous_geolevel_name IS NOT NULL 
					SET @sql_stmt+=@tab + @tab + 'SELECT ' + LOWER(@geolevel_name) + 
						', COUNT(DISTINCT(' + @previous_geolevel_name + ')) AS total' + @crlf +
						@tab + @tab + '  FROM ' + LOWER(@l_hierarchytable) + @crlf +
						@tab + @tab + ' GROUP BY ' + LOWER(@geolevel_name) + @crlf +
						@tab + @tab + 'HAVING COUNT(DISTINCT(' + @previous_geolevel_name + ')) > 1' + 
						') as' + CAST(@geolevel_id AS VARCHAR) + ')' + @crlf;
			END;
		ELSE
			RAISERROR('Invalid check type: %s, valid types are: ''missing'', ''spurious additional'', or ''multiple hierarchy''', 
				1, 16, @l_type 	/* Check type */);
		SET @previous_geolevel_name=LOWER(@geolevel_name);
--
		FETCH NEXT FROM c2 INTO @geolevel_id, @geolevel_name, @lookup_table;
	END;
	CLOSE c2;
--
	SET @i=0;
	OPEN c2;
	FETCH NEXT FROM c2 INTO @geolevel_id, @geolevel_name, @lookup_table;
	WHILE @@FETCH_STATUS = 0
	BEGIN
		SET @i+=1;
		IF @l_type = 'multiple hierarchy' 
			BEGIN
			IF @i = 1
				noop2:
			ELSE IF @i > 2
				SET @sql_stmt+=@crlf + 'UNION' + @crlf + 'SELECT CAST(''' + LOWER(@geolevel_name) + 
					''' AS VARCHAR) AS col, ' + @crlf + 
					@tab + 'a' + CAST(@geolevel_id AS VARCHAR) + '.' + 
					LOWER(@geolevel_name) + '_total AS val' + @crlf +
					'  FROM a' + CAST(@geolevel_id AS VARCHAR);
			ELSE
				SET @sql_stmt+='SELECT CAST(''' + LOWER(@geolevel_name) + ''' AS VARCHAR) AS col,' + @crlf + 
					@tab + 'a' + CAST(@geolevel_id AS VARCHAR) + '.' + LOWER(@geolevel_name) + 
					'_total AS val' + @crlf +
					'  FROM a' + CAST(@geolevel_id AS VARCHAR);
			END;
		ELSE
			BEGIN
			IF @i != 1 
				SET @sql_stmt+=@crlf + 'UNION' + @crlf + 'SELECT CAST(''' + LOWER(@geolevel_name) + 
					''' AS VARCHAR) AS col, ' + @crlf + 
					@tab + 'a' + CAST(@geolevel_id AS VARCHAR) + '.' + 
					LOWER(@geolevel_name) + '_total AS val' + @crlf +
					'  FROM a' + CAST(@geolevel_id AS VARCHAR);
			ELSE
				SET @sql_stmt+='SELECT CAST(''' + LOWER(@geolevel_name) + ''' AS VARCHAR) AS col,' + @crlf + 
					@tab + 'a' + CAST(@geolevel_id AS VARCHAR) + '.' + LOWER(@geolevel_name) + 
					'_total AS val' + @crlf +
					'  FROM a' + CAST(@geolevel_id AS VARCHAR);
			END;	
--
		FETCH NEXT FROM c2 INTO @geolevel_id, @geolevel_name, @lookup_table;
	END;
	CLOSE c2;
--
	DEALLOCATE c2;
--	
	PRINT 'SQL> ' + @sql_stmt;
    DECLARE @results AS TABLE (
		col VARCHAR(200), val NUMERIC) 
	INSERT into @results EXECUTE sp_executesql @sql_stmt;
--
-- Process results table
--	
	DECLARE @col AS VARCHAR(200);
	DECLARE @val AS NUMERIC;
	DECLARE c1 CURSOR FOR
		SELECT col, val
		  FROM @results;
	OPEN c1;
	FETCH NEXT FROM c1 INTO @col, @val;
	WHILE @@FETCH_STATUS = 0
	BEGIN
		PRINT 'Geography: ' + @l_geography + ' geolevel: ' + @col + ' has ' + CAST(@val AS VARCHAR) + 
			' ' + @l_type + ' codes';
		IF @val != 0
			SET @error_count+=1;	
--
		FETCH NEXT FROM c1 INTO @col, @val;
	END;
	CLOSE c1;  
--
	DEALLOCATE c1;
END;;
GO

-- SQL statement 169: Comment function check_hierarchy_cb_2014_us_500k >>>
DECLARE @CurrentUser sysname  /*
 * SQL statement name: 	check_hierarchy_function_comment.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: function name; e.g. check_hierarchy_cb_2014_us_500k
 *
 * Description:			Create hierarchy check function comment
 * Note:				%% becomes % after substitution
 */
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty 'MS_Description',   
   'Procedure: 		check_hierarchy_check_hierarchy_cb_2014_us_500k()
Parameters:		Geography, hierarchy table, type: "missing", "spurious additional" or "multiple hierarchy", 
				Error count (OUT)
Returns:		Nothing
Description:	Diff geography hierarchy table using dynamic method 4
				Also tests the hierarchy, i.e. all a higher resolutuion is contained by one of the next higher and so on

Example of dynamic SQL. Note the use of an array return type to achieve method 4

WITH /* missing */ a1 AS (
        SELECT COUNT(*) AS cb_2014_us_nation_5m_total
          FROM (
                SELECT cb_2014_us_nation_5m FROM hierarchy_cb_2014_us_500k
                EXCEPT
                SELECT cb_2014_us_nation_5m FROM lookup_cb_2014_us_nation_5m) as1)
, a2 AS (
        SELECT COUNT(*) AS cb_2014_us_state_500k_total
          FROM (
                SELECT cb_2014_us_state_500k FROM hierarchy_cb_2014_us_500k
                EXCEPT
                SELECT cb_2014_us_state_500k FROM lookup_cb_2014_us_state_500k) as2)
, a3 AS (
        SELECT COUNT(*) AS cb_2014_us_county_500k_total
          FROM (
                SELECT cb_2014_us_county_500k FROM hierarchy_cb_2014_us_500k
                EXCEPT
                SELECT cb_2014_us_county_500k FROM lookup_cb_2014_us_county_500k) as3)
SELECT ARRAY[a1.cb_2014_us_nation_5m_total, a2.cb_2014_us_state_500k_total, a3.cb_2014_us_county_500k_total] AS res_array
FROM a1, a2, a3;

Or: 

WITH /* multiple hierarchy */ a2 AS (
        SELECT COUNT(*) AS cb_2014_us_state_500k_total
          FROM (
                SELECT cb_2014_us_state_500k, COUNT(DISTINCT(cb_2014_us_nation_5m)) AS total
                  FROM hierarchy_cb_2014_us_500k
                 GROUP BY cb_2014_us_state_500k
                HAVING COUNT(DISTINCT(cb_2014_us_nation_5m)) > 1) as2)
, a3 AS (
        SELECT COUNT(*) AS cb_2014_us_county_500k_total
          FROM (
                SELECT cb_2014_us_county_500k, COUNT(DISTINCT(cb_2014_us_state_500k)) AS total
                  FROM hierarchy_cb_2014_us_500k
                 GROUP BY cb_2014_us_county_500k
                HAVING COUNT(DISTINCT(cb_2014_us_state_500k)) > 1) as3)
SELECT ARRAY[a2.cb_2014_us_state_500k_total, a3.cb_2014_us_county_500k_total] AS res_array
FROM a2, a3;
',
   'user', @CurrentUser,   
   'procedure', 'check_hierarchy_cb_2014_us_500k';
GO

-- SQL statement 170: Insert into hierarchy_cb_2014_us_500k >>>
DECLARE @l_geography AS VARCHAR(200)='cb_2014_us_500k';
/*
 * SQL statement name: 	insert_hierarchy.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: geography; e.g. cb_2014_us_500k
 *
 * Description:			Create insert statement into hierarchy table
 * Note:				%% becomes % after substitution
 */
--
	
--
DECLARE c1_hier CURSOR FOR
		SELECT geolevel_id, geolevel_name, shapefile_table, shapefile_area_id_column, shapefile_desc_column 
		  FROM geolevels_cb_2014_us_500k
		 WHERE geography = @l_geography
		 ORDER BY geography, geolevel_id;
DECLARE c2_hier CURSOR FOR
		SELECT i.name AS index_name, 
		       object_name(object_id) AS table_name
  		  FROM sys.indexes i
		 WHERE i.object_id = (
					 SELECT object_id(LOWER(hierarchytable))
				       FROM geography_cb_2014_us_500k
				      WHERE geography = @l_geography)
		 ORDER BY 1;		 
DECLARE c4_hier CURSOR FOR		 
	SELECT geography, hierarchytable
		  FROM geography_cb_2014_us_500k
		 WHERE geography = @l_geography;
DECLARE @c3 CURSOR;
DECLARE @geography		AS	VARCHAR(200);
DECLARE @hierarchytable AS 	VARCHAR(200);
--
DECLARE @columns		AS	VARCHAR(200);
DECLARE @sql_stmt	 	AS	NVARCHAR(max);
DECLARE @num_geolevels	AS	INTEGER=0;
--
DECLARE @geolevel_id 				AS INTEGER;
DECLARE @geolevel_name 				AS VARCHAR(200);
DECLARE @shapefile_table		 	AS VARCHAR(200);
DECLARE @shapefile_area_id_column 	AS VARCHAR(200);
DECLARE @shapefile_desc_column 		AS VARCHAR(200);
DECLARE @n_geolevel_name 			AS VARCHAR(200);
DECLARE @n_shapefile_table		 	AS VARCHAR(200);
DECLARE @n_shapefile_area_id_column AS VARCHAR(200);
DECLARE @n_shapefile_desc_column 	AS VARCHAR(200);
--
DECLARE @tablename	 	AS VARCHAR(200);
DECLARE @indexname	 	AS VARCHAR(200);

DECLARE @i 				AS INTEGER=0;
--
DECLARE @crlf			AS VARCHAR(2)=CHAR(10)+CHAR(13);
DECLARE @tab			AS VARCHAR(1)=CHAR(9);
--
DECLARE @rowcount		AS INTEGER=0;

--
BEGIN
--
	OPEN c4_hier;
	FETCH c4_hier INTO @geography, @hierarchytable;
	CLOSE c4_hier;
	DEALLOCATE c4_hier;
--
	IF @geography IS NULL
		RAISERROR('geography: %s not found', 16, 1, @l_geography	/* Geography */);
--
	 PRINT 'Populating ' + @l_geography + ' geography hierarchy table: ' + @hierarchytable + 
		'; spid: ' + CAST(@@spid AS VARCHAR);

	SET @num_geolevels=0;
	OPEN c1_hier;
	FETCH NEXT FROM c1_hier INTO @geolevel_id, @geolevel_name, @shapefile_table, 
								 @shapefile_area_id_column, @shapefile_desc_column;
	WHILE @@FETCH_STATUS = 0
	BEGIN
		SET @num_geolevels+=1;	
		IF @num_geolevels = 1 
			SET @columns=LOWER(@geolevel_name);
		ELSE
			SET @columns+=', ' + LOWER(@geolevel_name);
		FETCH NEXT FROM c1_hier INTO @geolevel_id, @geolevel_name, @shapefile_table, 
									 @shapefile_area_id_column, @shapefile_desc_column;
	END;
	CLOSE c1_hier;
--	
	IF @num_geolevels = 0 
		RAISERROR('No rows found in: geolevels_%s for geography %s', 16, 1, @l_geography, @l_geography);
--
-- CTE x<n><n+1> - CROSS JOINs with intersections
--
	OPEN c1_hier;
	FETCH NEXT FROM c1_hier INTO @geolevel_id, @geolevel_name, @shapefile_table, 
								 @shapefile_area_id_column, @shapefile_desc_column;
	WHILE @@FETCH_STATUS = 0
	BEGIN
		SET @i+=1;

		DECLARE c1a_hier CURSOR FOR
				SELECT geolevel_name, shapefile_table, shapefile_area_id_column, shapefile_desc_column 
				  FROM geolevels_cb_2014_us_500k
				 WHERE geography   = @l_geography
				   AND geolevel_id = @geolevel_id+1
				 ORDER BY geography, geolevel_id;		
		OPEN c1a_hier;
		FETCH NEXT FROM c1a_hier INTO @n_geolevel_name, @n_shapefile_table, 
									  @n_shapefile_area_id_column, @n_shapefile_desc_column;
		CLOSE c1a_hier;
		DEALLOCATE c1a_hier;

--		PRINT 'i: ' + CAST(@i AS VARCHAR) + '; num_geolevels: ' + CAST(@num_geolevels AS VARCHAR) + 
--			'; geolevel_name: ' + @geolevel_name + '; n_geolevel_name: ' + @n_geolevel_name;
		IF @i = 1
/* E.g

SELECT a1.areaid AS cb_2014_us_nation_5m,
	   a2.areaid AS cb_2014_us_state_500k,
	   a2.geom_11.STArea() AS a2_area,
	   a1.geom_11.STIntersection(a2.geom_11).STArea() AS a12_area
  INTO dbo.#x12
  FROM cb_2014_us_nation_5m a1   CROSS JOIN cb_2014_us_state_500k a2
 WHERE a1.geom_11.STIntersects(a2.geom_11) = 1;
	
Postgres Original: 
	
x23 AS (
	SELECT a2.areaid AS level2,
       	   a3.areaid AS level3,
  	       ST_Area(a3.geom) AS a3_area,
	       ST_Area(ST_Intersection(a2.geom, a3.geom)) AS a23_area
          FROM a2 CROSS JOIN a3
	 WHERE ST_Intersects(a2.geom, a3.geom)
 */		
			BEGIN
				SET @sql_stmt=			
					'SELECT /* Subqueries x' +
						CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + ' ... x' +
						CAST(@num_geolevels-1 AS VARCHAR) + CAST(@num_geolevels AS VARCHAR) +
						': intersection aggregate geometries starting from the lowest resolution.' + @crlf + 
						@tab + '       Created using N-1 geoevels cross joins rather than 1 to minimise cross join size and hence improve performance.' + @crlf +
						@tab + '       Calculate the area of the higher resolution geolevel and the area of the intersected area */' + @crlf +
					'       a' + CAST(@i AS VARCHAR) + '.areaid AS ' + @geolevel_name + ',' + @crlf + 
					'       a' + CAST(@i+1 AS VARCHAR) + '.areaid AS ' + @n_geolevel_name + ',' + @crlf +
					'       a' + CAST(@i+1 AS VARCHAR) + '.geom_11.STArea() AS a' + CAST(@i+1 AS VARCHAR) + '_area,' + @crlf + 
					'       a' + CAST(@i AS VARCHAR) + '.geom_11.STIntersection(a' + CAST(@i+1 AS VARCHAR) + '.geom_11).STArea() AS a' + 
						CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + '_area' + @crlf + 
				    '  INTO ##x' + CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + '_' + CAST(@@spid AS VARCHAR) + @crlf + 
					'  FROM ' + @shapefile_table + ' a' + CAST(@i AS VARCHAR) + 
					' CROSS JOIN ' + @n_shapefile_table + ' a' + CAST(@i+1 AS VARCHAR) + '' + @crlf + 
					' WHERE a' + CAST(@i AS VARCHAR) + '.geom_11.STIntersects(a' + CAST(@i+1 AS VARCHAR) + 
						'.geom_11) = 1';
				PRINT 'SQL> ' + @sql_stmt;
				EXECUTE @rowcount = sp_executesql @sql_stmt;	
			END;			
		ELSE IF @i < (@num_geolevels-1) 
/* E.g

SELECT a2.areaid AS cb_2014_us_state_500k,
	   a3.areaid AS cb_2014_us_county_500k,
	   a3.geom_11.STArea() AS a3_area,
	   a2.geom_11.STIntersection(a3.geom_11).ST_Area() AS a23_area
  INTO dbo.#x23
  FROM cb_2014_us_state_500k a2  CROSS JOIN cb_2014_us_county_500k a3
 WHERE a2.geom_11.ST_Intersects(a3.geom_11) = 1;

*/
			BEGIN
				SET @sql_stmt=
					'SELECT /* Subqueries x' + 
						CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + ' ... x' + 
						CAST(@num_geolevels-1 AS VARCHAR) + CAST(@num_geolevels AS VARCHAR) + 
						': intersection aggregate geometries starting from the lowest resolution.' + @crlf + 
						@tab + '       Created using N-1 geoevels cross joins rather than 1 to minimise cross join size and hence improve performance.' + @crlf + 
						@tab + '       Calculate the area of the higher resolution geolevel and the area of the intersected area */' + @crlf + 
					'       a' + CAST(@i AS VARCHAR) + '.areaid AS ' + @geolevel_name + ',' + @crlf + 
					'       a' + CAST(@i+1 AS VARCHAR) + '.areaid AS ' + @n_geolevel_name + ',' + @crlf + 
					'       a' + CAST(@i+1 AS VARCHAR) + '.geom_11.STArea() AS a' + CAST(@i+1 AS VARCHAR) + '_area,' + @crlf + 
					'       a' + CAST(@i AS VARCHAR) + '.geom_11.STIntersection(a' + CAST(@i+1 AS VARCHAR) + '.geom_11).STArea() AS a' + CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + '_area' + @crlf + 
				    '  INTO ##x' + CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + '_' + CAST(@@spid AS VARCHAR) + @crlf + 
					'  FROM ' + @shapefile_table + ' a' + CAST(@i AS VARCHAR) + 
					' CROSS JOIN ' + @n_shapefile_table + ' a' + CAST(@i+1 AS VARCHAR) + '' + @crlf + 
					' WHERE a' + CAST(@i AS VARCHAR) + '.geom_11.ST_Intersects(a' + CAST(@i+1 AS VARCHAR) + 
						'.geom_11) = 1';
				PRINT 'SQL> ' + @sql_stmt;
				EXECUTE @rowcount = sp_executesql @sql_stmt;
			END;
		ELSE IF @i < @num_geolevels
/* E.g.

SELECT a2.areaid AS cb_2014_us_state_500k,
	   a3.areaid AS cb_2014_us_county_500k,
	   a3.geom_11.STArea() AS a3_area,
	   a2.geom_11.STIntersection(a3.geom_11).STArea() AS a23_area
  INTO dbo.#x23
  FROM cb_2014_us_state_500k a2 CROSS JOIN cb_2014_us_county_500k a3
 WHERE a2.geom_11.STIntersects(a3.geom_11) = 1;
		
Postgres Original: 

 x34 AS (
	SELECT a3.level3, 
	       a4.level4,
  	       ST_Area(a4.geom) AS a4_area,
	       ST_Area(ST_Intersection(a3.geom, a4.geom)) a34_area
          FROM a3 CROSS JOIN a4
	 WHERE ST_Intersects(a3.geom, a4.geom)
*/
			BEGIN
				SET @sql_stmt=
					'SELECT /* Subqueries x' + 
						CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + ' ... x' + 
						CAST(@num_geolevels-1 AS VARCHAR) + CAST(@num_geolevels AS VARCHAR) + 
						': intersection aggregate geometries starting from the lowest resolution.' + @crlf + 
						@tab + '       Created using N-1 geoevels cross joins rather than 1 to minimise cross join size and hence improve performance.' + @crlf + 
						@tab + '       Calculate the area of the higher resolution geolevel and the area of the intersected area */' + @crlf + 
					'       a' + CAST(@i AS VARCHAR) + '.areaid AS ' + @geolevel_name + ',' + @crlf + 
					'       a' + CAST(@i+1 AS VARCHAR) + '.areaid AS ' + @n_geolevel_name + ',' + @crlf + 
					'       a' + CAST(@i+1 AS VARCHAR) + '.geom_11.STArea() AS a' + CAST(@i+1 AS VARCHAR) + '_area,' + @crlf + 
					'       a' + CAST(@i AS VARCHAR) + '.geom_11.STIntersection(a' + CAST(@i+1 AS VARCHAR) + '.geom_11).STArea() AS a' + CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + '_area' + @crlf + 
				    '  INTO ##x' + CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + '_' + CAST(@@spid AS VARCHAR) + @crlf + 
					'  FROM ' + @shapefile_table + ' a' + CAST(@i AS VARCHAR) + ' CROSS JOIN ' + @n_shapefile_table + ' a' + CAST(@i+1 AS VARCHAR) + '' + @crlf + 
					' WHERE a' + CAST(@i AS VARCHAR) + '.geom_11.STIntersects(a' + CAST(@i+1 AS VARCHAR) + 
						'.geom_11) = 1';
				PRINT 'SQL> ' + @sql_stmt;
				EXECUTE @rowcount = sp_executesql @sql_stmt;
			END;
		FETCH NEXT FROM c1_hier INTO @geolevel_id, @geolevel_name, @shapefile_table, 
									 @shapefile_area_id_column, @shapefile_desc_column;
	END;
	CLOSE c1_hier;
--
-- CTE: y - compute intersected area, order analytically
--

/*
	SELECT x12.level1, x12.level2, x23.level3, x34.level4, 
	       CASE WHEN a2_area > 0 THEN a12_area/a2_area ELSE NULL END test12,
	       CASE WHEN a3_area > 0 THEN a23_area/a3_area ELSE NULL END test23,
	       CASE WHEN a4_area > 0 THEN a34_area/a4_area ELSE NULL END test34,
	       MAX(a12_area/a2_area) OVER (PARTITION BY x12.level2) AS max12,
	       MAX(a23_area/a3_area) OVER (PARTITION BY x23.level3) AS max23,
	       MAX(a34_area/a4_area) OVER (PARTITION BY x34.level4) AS max34
	  INTO #y
	  FROM x12, x23, x34
	 WHERE x12.level2 = x23.level2
   	   AND x23.level3 = x34.level3;
)
 */
	SET @sql_stmt=@crlf + 
		'SELECT /* Join x' + CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + ' ... x' + CAST(@num_geolevels-1 AS VARCHAR) + CAST(@num_geolevels AS VARCHAR) + 
			'intersections, pass through the computed areas, compute intersected area/higher resolution geolevel area,' + @crlf + 
		@tab + '     compute maximum intersected area/higher resolution geolevel area using an analytic partition of all' + @crlf + 
		@tab + '     duplicate higher resolution geolevels */' + @crlf;
--
-- First line of SELECT statement
--
	SET @i=0;
	OPEN c1_hier;
	FETCH NEXT FROM c1_hier INTO @geolevel_id, @geolevel_name, @shapefile_table, 
								 @shapefile_area_id_column, @shapefile_desc_column;
	WHILE @@FETCH_STATUS = 0
	BEGIN
		SET @i+=1;	
									 
		DECLARE c1a_hier CURSOR FOR
				SELECT geolevel_name, shapefile_table, shapefile_area_id_column, shapefile_desc_column 
				  FROM geolevels_cb_2014_us_500k
				 WHERE geography   = @l_geography
				   AND geolevel_id = @geolevel_id+1
				 ORDER BY geography, geolevel_id;		
		OPEN c1a_hier;
		FETCH NEXT FROM c1a_hier INTO @n_geolevel_name, @n_shapefile_table, 
									  @n_shapefile_area_id_column, @n_shapefile_desc_column;
		CLOSE c1a_hier;
		DEALLOCATE c1a_hier;
		
--		PRINT 'i: ' + CAST(@i AS VARCHAR) + '; num_geolevels: ' + CAST(@num_geolevels AS VARCHAR) + 
--			'; geolevel_name: ' + @geolevel_name + '; n_geolevel_name: ' + @n_geolevel_name;
			
		IF @i < @num_geolevels 
		BEGIN
			IF @i = 1
				SET @sql_stmt+=
					@tab + '       x' + CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + '.' + 
						@geolevel_name + ', ' + @crlf;
			SET @sql_stmt+=
				@tab + '       x' + CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + '.' + 
					@n_geolevel_name + ', ' + @crlf;
		END;
		
		FETCH NEXT FROM c1_hier INTO @geolevel_id, @geolevel_name, @shapefile_table, 
									 @shapefile_area_id_column, @shapefile_desc_column;
	END;
	CLOSE c1_hier;
--
-- Add CASE, MAX lines
-- 
	SET @i=0;
	OPEN c1_hier;
	FETCH NEXT FROM c1_hier INTO @geolevel_id, @geolevel_name, @shapefile_table, 
								 @shapefile_area_id_column, @shapefile_desc_column;
	WHILE @@FETCH_STATUS = 0
	BEGIN
		SET @i+=1;	
									 
		DECLARE c1a_hier CURSOR FOR
				SELECT geolevel_name, shapefile_table, shapefile_area_id_column, shapefile_desc_column 
				  FROM geolevels_cb_2014_us_500k
				 WHERE geography   = @l_geography
				   AND geolevel_id = @geolevel_id+1
				 ORDER BY geography, geolevel_id;		
		OPEN c1a_hier;
		FETCH NEXT FROM c1a_hier INTO @n_geolevel_name, @n_shapefile_table, 
									  @n_shapefile_area_id_column, @n_shapefile_desc_column;
		CLOSE c1a_hier;
		DEALLOCATE c1a_hier;
		
--		PRINT 'i: ' + CAST(@i AS VARCHAR) + '; num_geolevels: ' + CAST(@num_geolevels AS VARCHAR) + 
--			'; geolevel_name: ' + @geolevel_name + '; n_geolevel_name: ' + @n_geolevel_name;
			
		IF @i < @num_geolevels 
		BEGIN
			SET @sql_stmt+=
	    		@tab + '       CASE WHEN x' + CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + '.a' + 
						CAST(@i+1 AS VARCHAR) + '_area > 0 THEN x' + CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + 
						'.a' + CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + '_area/x' + 
						CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + '.a' + CAST(@i+1 AS VARCHAR) + 
					'_area ELSE NULL END test' + CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + ',' + @crlf +
				@tab + '       MAX(x' + CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + '.a' + 
					CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + '_area/x' + 
					CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + '.a' + CAST(@i+1 AS VARCHAR) + '_area)' + 
					' OVER (PARTITION BY x' + CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + 
					'.' + @n_geolevel_name + ') AS max' + CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + ',' + @crlf;		
		END;
		
		FETCH NEXT FROM c1_hier INTO @geolevel_id, @geolevel_name, @shapefile_table, 
									 @shapefile_area_id_column, @shapefile_desc_column;
	END;
	CLOSE c1_hier;
--
-- Trim last CRLF
--
	SET @sql_stmt=SUBSTRING(@sql_stmt, 1, LEN(@sql_stmt)-LEN(','+@crlf)) /* Chop off last ",\r\n" */ + @crlf;
--
-- Add INTO clause
--
	SET @sql_stmt+='  INTO ##y' + '_' + CAST(@@spid AS VARCHAR) + @crlf;
--
-- Add FROM clause
-- 
	SET @i=0;
	OPEN c1_hier;
	FETCH NEXT FROM c1_hier INTO @geolevel_id, @geolevel_name, @shapefile_table, 
								 @shapefile_area_id_column, @shapefile_desc_column;
	WHILE @@FETCH_STATUS = 0
	BEGIN
		SET @i+=1;	
		
--		PRINT 'i: ' + CAST(@i AS VARCHAR) + '; num_geolevels: ' + CAST(@num_geolevels AS VARCHAR) + 
--			'; geolevel_name: ' + @geolevel_name + '; n_geolevel_name: ' + @n_geolevel_name;
			
		IF @i < @num_geolevels 
		BEGIN
			IF @i = 1 
				SET @sql_stmt+='  FROM ##x' + CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) +
					'_' + CAST(@@spid AS VARCHAR) +
					' x' + CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR);
			ELSE
				SET @sql_stmt+=', ##x' + CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + 
					'_' + CAST(@@spid AS VARCHAR) +
					' x' + CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR);
		END;
		
		FETCH NEXT FROM c1_hier INTO @geolevel_id, @geolevel_name, @shapefile_table, 
									 @shapefile_area_id_column, @shapefile_desc_column;
	END;
	CLOSE c1_hier;
--
-- Add WHERE clause
-- 
	SET @i=0;
	OPEN c1_hier;
	FETCH NEXT FROM c1_hier INTO @geolevel_id, @geolevel_name, @shapefile_table, 
								 @shapefile_area_id_column, @shapefile_desc_column;
	WHILE @@FETCH_STATUS = 0
	BEGIN
		SET @i+=1;	
									 
		DECLARE c1a_hier CURSOR FOR
				SELECT geolevel_name, shapefile_table, shapefile_area_id_column, shapefile_desc_column 
				  FROM geolevels_cb_2014_us_500k
				 WHERE geography   = @l_geography
				   AND geolevel_id = @geolevel_id+1
				 ORDER BY geography, geolevel_id;		
		OPEN c1a_hier;
		FETCH NEXT FROM c1a_hier INTO @n_geolevel_name, @n_shapefile_table, 
									  @n_shapefile_area_id_column, @n_shapefile_desc_column;
		CLOSE c1a_hier;
		DEALLOCATE c1a_hier;
		
--		PRINT 'i: ' + CAST(@i AS VARCHAR) + '; num_geolevels: ' + CAST(@num_geolevels AS VARCHAR) + 
--			'; geolevel_name: ' + @geolevel_name + '; n_geolevel_name: ' + @n_geolevel_name;
			
		IF @i < (@num_geolevels-1) /* FOR i IN 1 .. (num_geolevels-2) LOOP */
		BEGIN
			IF @i = 1 
				SET @sql_stmt+=@crlf + 
					' WHERE x' + CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + '.' + @n_geolevel_name + 
						' = x' + CAST(@i+1 AS VARCHAR) + CAST(@i+2 AS VARCHAR) + '.' + @n_geolevel_name;
			ELSE
				SET @sql_stmt+=@crlf + 
					'   AND x' + CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + '.' + @n_geolevel_name + 
						' = x' + CAST(@i+1 AS VARCHAR) + CAST(@i+2 AS VARCHAR) + '.' + @n_geolevel_name;
		END;		
		FETCH NEXT FROM c1_hier INTO @geolevel_id, @geolevel_name, @shapefile_table, 
									 @shapefile_area_id_column, @shapefile_desc_column;
	END;
	CLOSE c1_hier;	
--
-- Run SQL to create Y
--
	PRINT 'SQL> ' + @sql_stmt;
	EXECUTE @rowcount = sp_executesql @sql_stmt;
--
-- Drop x_NN temporary tables
--
	SET @i=1;
	WHILE @i < @num_geolevels
	BEGIN
		SET @sql_stmt='DROP TABLE ##x' + CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + 
				 '_' + CAST(@@spid AS VARCHAR);
		PRINT 'SQL> ' + @sql_stmt;
		EXECUTE @rowcount = sp_executesql @sql_stmt;
		SET @i+=1;	
	END;
	
--
-- Insert statement and columns
--
	SET @sql_stmt='INSERT INTO ' + LOWER(@hierarchytable) + ' (' + @columns + ')' + @crlf;	
	
--	
-- Final SELECT
--
/*
SELECT level1, level2, level3, level4,
  FROM y
 WHERE max12 = test12
   AND max23 = test23
   AND max34 = test34
 ORDER BY 1, 2, 3, 4;  
 */
	SET @sql_stmt+='SELECT /* Select y intersection, eliminating duplicates using selecting the lower geolevel resolution' + @crlf + 
         @tab + ' with the largest intersection by area for each (higher resolution) geolevel */' + @crlf + '       ' + @columns + @crlf +
		'  FROM ##y_' + CAST(@@spid AS VARCHAR) + @crlf;
--
-- WHERE clause
--
	SET @i=1;
	WHILE @i < @num_geolevels
	BEGIN
		IF @i = 1
			SET @sql_stmt+=' WHERE max' + CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + 
				' = test' + CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + @crlf;
		ELSE
			SET @sql_stmt+='   AND max' + CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + 
				' = test' + CAST(@i AS VARCHAR) + CAST(@i+1 AS VARCHAR) + @crlf;
		SET @i+=1;	
	END;
--
-- ORDER BY clause
--	
	SET @sql_stmt+=' ORDER BY 1';
	SET @i=2;
	WHILE @i <= @num_geolevels /* FOR i IN 2 .. num_geolevels LOOP */
	BEGIN	
		SET @sql_stmt+=', ' + CAST(@i AS VARCHAR);
		SET @i+=1;	
	END;	
--
	DEALLOCATE c1_hier;
--
	PRINT 'SQL> ' + @sql_stmt;
--
-- Execute SQL statement
--
	EXECUTE @i=sp_executesql @sql_stmt
	SET @rowcount = @@ROWCOUNT;
--
-- Drop Y temp table
--	
	SET @sql_stmt='DROP TABLE ##y_' + CAST(@@spid AS VARCHAR);
	PRINT 'SQL> ' + @sql_stmt;
	EXECUTE sp_executesql @sql_stmt;
	SELECT name FROM tempdb.sys.objects;
--
-- Check rows were inserted
--	
	IF @rowcount = 0 
		RAISERROR('No rows found in %s geography hierarchy table: %s; sp_executesql rval: %d', 16, 1, 
			@l_geography 			/* Geography */,
			@hierarchytable			/* Hierarchy table */,
			@i						/* Return value from sp_executesql() */);
--
-- Re-index
--
	OPEN c2_hier;
	FETCH NEXT FROM c2_hier INTO @indexname, @tablename;
	WHILE @@FETCH_STATUS = 0
	BEGIN
		SET @sql_stmt='ALTER INDEX ' + @indexname + ' ON ' + @tablename + ' REORGANIZE';
		PRINT 'SQL> ' + @sql_stmt;
		EXECUTE sp_executesql @sql_stmt;	
		FETCH NEXT FROM c2_hier INTO @indexname, @tablename;
	END;
	CLOSE c2_hier;
	DEALLOCATE c2_hier;
--
-- Analyze
--
	SET @sql_stmt='UPDATE STATISTICS ' + LOWER(@hierarchytable);
	PRINT 'SQL> ' + @sql_stmt;
	EXECUTE sp_executesql @sql_stmt;			
END;
GO

-- SQL statement 171: Check intersctions  for geograpy: cb_2014_us_500k >>>
DECLARE @l_geography AS VARCHAR(200)='cb_2014_us_500k';
/*
 * SQL statement name: 	check_intersections.sql
 * Type:				Microsoft SQL Server T/sql anonymous block
 * Parameters:
 *						1: geography; e.g. cb_2014_us_500k
 *
 * Description:			Check intersections
 * Note:				% becomes % after substitution
 */
--
	DECLARE c1 CURSOR FOR
		SELECT geography, hierarchytable
		  FROM geography_cb_2014_us_500k
		 WHERE geography = @l_geography;
--
	DECLARE @geography 		AS VARCHAR(30);
	DECLARE @hierarchytable AS VARCHAR(200);
--
	DECLARE @CurrentUser	AS VARCHAR(60);
	DECLARE @function_name	AS VARCHAR(200);
	DECLARE @l_type			AS VARCHAR(30);
--
	DECLARE @e AS INTEGER=0;
	DECLARE @f AS INTEGER=0;
	DECLARE @g AS INTEGER=0;
BEGIN
--
	OPEN c1;
	FETCH c1 INTO @geography, @hierarchytable;
	CLOSE c1;
	DEALLOCATE c1;
--
	IF @geography IS NULL
		RAISERROR('geography: % not found', 16, 1, @l_geography	/* Geography */);
--
-- Call diff and multiple hierarchy tests
--
	SELECT @CurrentUser = user_name(); 
	SET @function_name=@CurrentUser + '.check_hierarchy_cb_2014_us_500k';
	SET @l_type='missing';
	EXECUTE @function_name @geography, @hierarchytable, @l_type, @e;
	SET @l_type='spurious additional';
	EXECUTE @function_name @geography, @hierarchytable, @l_type, @f;
	SET @l_type='multiple hierarchy';
	EXECUTE @function_name @geography, @hierarchytable, @l_type, @g;
--
	IF @e+@f > 0
		RAISERROR('Geography: %s codes check %d missing, %d spurious additional, %d hierarchy fails', 16, 1,  
			@geography	/* Geography */, 
			@e			/* Missing */, 
			@f			/* Spurious additional */, 
			@g			/* Multiple hierarchy */);
	ELSE
		PRINT 'Geography: ' + @geography + ' codes check OK';
END;;
GO

--
-- Create tiles tables
--

-- SQL statement 173: Create function: longitude2tile.sql >>>
/*
 * SQL statement name: 	longitude2tile.sql
 * Type:				Postgres/PostGIS PL/pgsql function
 * Parameters:			None
 *
 * Description:			Convert longitude (WGS84 - 4326) to OSM tile x
 * Note:				% becomes % after substitution
 */
IF OBJECT_ID (N'tileMaker_longitude2tile', N'FN') IS NOT NULL  
    DROP FUNCTION tileMaker_longitude2tile;  
GO 

CREATE FUNCTION tileMaker_longitude2tile(@longitude DOUBLE PRECISION, @zoom_level INTEGER)
RETURNS INTEGER AS
BEGIN
	DECLARE @tileX INTEGER;
	SET @tileX=CAST(
			FLOOR( (@longitude + 180) / 360 * POWER(2, @zoom_level) ) AS INTEGER);
	RETURN @tileX;
END;
GO
  
DECLARE @CurrentUser sysname;
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty  'MS_Description', 'Function: 	 tileMaker_longitude2tile()
Parameters:	 Longitude, zoom level
Returns:	 OSM Tile x
Description: Convert longitude (WGS84 - 4326) to OSM tile x

Derivation of the tile X/Y 

* Reproject the coordinates to the Mercator projection (from EPSG:4326 to EPSG:3857):

x = lon
y = arsinh(tan(lat)) = log[tan(lat) + sec(lat)]
(lat and lon are in radians)

* Transform range of x and y to 0  1 and shift origin to top left corner:

x = [1 + (x / p)] / 2
y = [1 - (y / p)] / 2

* Calculate the number of tiles across the map, n, using 2**zoom
* Multiply x and y by n. Round results down to give tilex and tiley.
',
   'user', @CurrentUser,   
   'function', 'tileMaker_longitude2tile';
GO

-- SQL statement 174: Create function: latitude2tile.sql >>>
/*
 * SQL statement name: 	latitude2tile.sql
 * Type:				Microsoft SQL Server T/sql function
 * Parameters:			None
 *
 * Description:			Convert latitude (WGS84 - 4326) to OSM tile y
 * Note:				% becomes % after substitution
 */
IF OBJECT_ID (N'tileMaker_latitude2tile', N'FN') IS NOT NULL  
    DROP FUNCTION tileMaker_latitude2tile;  
GO 

CREATE FUNCTION tileMaker_latitude2tile(@latitude DOUBLE PRECISION, @zoom_level INTEGER)
RETURNS INTEGER 
AS
BEGIN
	DECLARE @tileY INTEGER;
	SET @tileY=CAST(
					FLOOR( 
						(1.0 - LOG /* Natural Log */ 
							(TAN(RADIANS(@latitude)) + 1.0 / COS(RADIANS(@latitude))) / PI()) / 2.0 * POWER(2, @zoom_level) 
						) 
					AS INTEGER);
	RETURN @tileY;
END;
GO
  
DECLARE @CurrentUser sysname;
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty  'MS_Description', 'Function: 	 tileMaker_latitude2tile()
Parameters:	 Latitude, zoom level
Returns:	 OSM Tile y
Description: Convert latitude (WGS84 - 4326) to OSM tile x

Derivation of the tile X/Y 

* Reproject the coordinates to the Mercator projection (from EPSG:4326 to EPSG:3857):

x = lon
y = arsinh(tan(lat)) = log[tan(lat) + sec(lat)]
(lat and lon are in radians)

* Transform range of x and y to 0  1 and shift origin to top left corner:

x = [1 + (x / p)] / 2
y = [1 - (y / p)] / 2

* Calculate the number of tiles across the map, n, using 2**zoom
* Multiply x and y by n. Round results down to give tilex and tiley.
',
   'user', @CurrentUser,   
   'function', 'tileMaker_latitude2tile';
GO

-- SQL statement 175: Create function: tile2longitude.sql >>>
/*
 * SQL statement name: 	tile2longitude.sql
 * Type:				Postgres/PostGIS PL/pgsql function
 * Parameters:			None
 *
 * Description:			Convert OSM tile x to longitude (WGS84 - 4326) 
 * Note:				% becomes % after substitution
 */
IF OBJECT_ID (N'tileMaker_tile2longitude', N'FN') IS NOT NULL  
    DROP FUNCTION tileMaker_tile2longitude;  
GO 

CREATE FUNCTION tileMaker_tile2longitude(@x INTEGER, @zoom_level INTEGER)
RETURNS DOUBLE PRECISION AS
BEGIN
	DECLARE @longitude DOUBLE PRECISION;
	SET @longitude=CAST( ( (@x * 1.0) / POWER(2, @zoom_level) * 360.0) - 180.0 AS DOUBLE PRECISION);
	RETURN @longitude;
END;
GO
  
DECLARE @CurrentUser sysname;
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty  'MS_Description', 'Function: 	 tileMaker_tile2longitude()
Parameters:	 OSM Tile x, zoom level
Returns:	 Longitude
Description: Convert OSM tile x to longitude (WGS84 - 4326)
',
   'user', @CurrentUser,   
   'function', 'tileMaker_tile2longitude';
GO

-- SQL statement 176: Create function: tile2latitude.sql >>>
/*
 * SQL statement name: 	tileMaker_tile2latitude.sql
 * Type:				Postgres/PostGIS PL/pgsql function
 * Parameters:			None
 *
 * Description:			Convert OSM tile y to latitude (WGS84 - 4326)
 * Note:				% becomes % after substitution
 */
IF OBJECT_ID (N'tileMaker_tile2latitude', N'FN') IS NOT NULL  
    DROP FUNCTION tileMaker_tile2latitude;  
GO 

CREATE FUNCTION tileMaker_tile2latitude(@y INTEGER, @zoom_level INTEGER)
RETURNS DOUBLE PRECISION AS
BEGIN
	DECLARE @latitude DOUBLE PRECISION;
	DECLARE @n FLOAT;
	DECLARE @sinh FLOAT;
	DECLARE @E FLOAT = 2.7182818284;
	
    SET @n = PI() - (2.0 * PI() * @y) / POWER(2.0, @zoom_level);
    SET @sinh = (1 - POWER(@E, -2*@n)) / (2 * POWER(@E, -@n));
    SET @latitude = DEGREES(ATAN(@sinh));
	RETURN @latitude;
END;
GO
  
DECLARE @CurrentUser sysname;
SELECT @CurrentUser = user_name(); 
EXECUTE sp_addextendedproperty  'MS_Description', 'Function: 	 tileMaker_tile2latitude()
Parameters:	 OSM Tile y, zoom level
Returns:	 Latitude
Description: Convert OSM tile y to latitude (WGS84 - 4326)
',
   'user', @CurrentUser,   
   'function', 'tileMaker_tile2latitude';
GO

-- SQL statement 177: Tile check >>>
/*
 * SQL statement name: 	tileMaker_tile2latitude.sql
 * Type:				Postgres/PostGIS PL/pgsql function
 * Parameters:			
 *						1: Lowest resolution geolevels table
 *						2: Geography
 *						3: min_zoomlevel
 *						4: max_zoomlevel
 *						5: Geolevel id = 1 geometry table
 *
 * Description:			Convert OSM tile y to latitude (WGS84 - 4326)
 * Note:				% becomes % after substitution
 */
WITH a AS ( /* Geolevel summary */
		SELECT a1.geography, 
		       a1.geolevel_name AS min_geolevel_name,
               MIN(geolevel_id) AS min_geolevel_id,
               CAST(11 AS INTEGER) AS zoomlevel,
               a2.max_geolevel_id
          FROM geolevels_cb_2014_us_500k a1, (
                        SELECT geography, MAX(geolevel_id) AS max_geolevel_id
  						  FROM geolevels_cb_2014_us_500k 
						 GROUP BY geography
						) a2
         WHERE a1.geography     = 'cb_2014_us_500k' 
           AND a1.geography     = a2.geography
         GROUP BY a1.geography, a1.geolevel_name, a2.max_geolevel_id
        HAVING MIN(geolevel_id) = 1
), b AS ( /* Get bounds of geography */		
	SELECT a2.geography,
		   a2.min_geolevel_id,
		   a2.max_geolevel_id,
		   a2.zoomlevel,
		   CASE
				WHEN a2.zoomlevel <= 6 THEN
					geometry::STGeomFromWKB(b.geom_6.STAsBinary(), b.geom_6.STSrid /* Cast to geometry */).STEnvelope()
				WHEN a2.zoomlevel BETWEEN (6+1) AND 11 THEN	
					geometry::STGeomFromWKB(b.geom_11.STAsBinary(), b.geom_11.STSrid /* Cast to geometry */).STEnvelope()
				ELSE NULL
           END AS geom_envelope
      FROM cb_2014_us_nation_5m b, a a2
)
SELECT b.geography,
	   b.min_geolevel_id,
	   b.max_geolevel_id,
	   b.zoomlevel,
	   CAST(b.geom_envelope.STPointN(1).STX AS numeric(8,5)) AS Xmin,
	   CAST(b.geom_envelope.STPointN(3).STX AS numeric(8,5)) AS Xmax,
	   CAST(b.geom_envelope.STPointN(1).STY AS numeric(8,5)) AS Ymin,
	   CAST(b.geom_envelope.STPointN(3).STY AS numeric(8,5)) AS Ymax,
	   $(USERNAME).tileMaker_latitude2tile(b.geom_envelope.STPointN(1).STY, zoomlevel) AS Y_mintile,
	   $(USERNAME).tileMaker_latitude2tile(b.geom_envelope.STPointN(3).STY, zoomlevel) AS Y_maxtile,
	   $(USERNAME).tileMaker_longitude2tile(b.geom_envelope.STPointN(1).STX, zoomlevel) AS X_mintile,
	   $(USERNAME).tileMaker_longitude2tile(b.geom_envelope.STPointN(3).STX, zoomlevel) AS X_maxtile
  FROM b;
GO

-- SQL statement 178: Commit transaction >>>
COMMIT;
GO

--
-- Analyze tables
--

-- SQL statement 180: Describe table cb_2014_us_county_500k >>>
-- EXEC sp_help cb_2014_us_county_500k;
GO

-- SQL statement 181: Analyze table cb_2014_us_county_500k >>>
UPDATE STATISTICS cb_2014_us_county_500k;
GO

-- SQL statement 182: Describe table lookup_cb_2014_us_county_500k >>>
-- EXEC sp_help lookup_cb_2014_us_county_500k;
GO

-- SQL statement 183: Analyze table lookup_cb_2014_us_county_500k >>>
UPDATE STATISTICS lookup_cb_2014_us_county_500k;
GO

-- SQL statement 184: Describe table cb_2014_us_nation_5m >>>
-- EXEC sp_help cb_2014_us_nation_5m;
GO

-- SQL statement 185: Analyze table cb_2014_us_nation_5m >>>
UPDATE STATISTICS cb_2014_us_nation_5m;
GO

-- SQL statement 186: Describe table lookup_cb_2014_us_nation_5m >>>
-- EXEC sp_help lookup_cb_2014_us_nation_5m;
GO

-- SQL statement 187: Analyze table lookup_cb_2014_us_nation_5m >>>
UPDATE STATISTICS lookup_cb_2014_us_nation_5m;
GO

-- SQL statement 188: Describe table cb_2014_us_state_500k >>>
-- EXEC sp_help cb_2014_us_state_500k;
GO

-- SQL statement 189: Analyze table cb_2014_us_state_500k >>>
UPDATE STATISTICS cb_2014_us_state_500k;
GO

-- SQL statement 190: Describe table lookup_cb_2014_us_state_500k >>>
-- EXEC sp_help lookup_cb_2014_us_state_500k;
GO

-- SQL statement 191: Analyze table lookup_cb_2014_us_state_500k >>>
UPDATE STATISTICS lookup_cb_2014_us_state_500k;
GO

-- SQL statement 192: Describe table geolevels_cb_2014_us_500k >>>
-- EXEC sp_help geolevels_cb_2014_us_500k;
GO

-- SQL statement 193: Analyze table geolevels_cb_2014_us_500k >>>
UPDATE STATISTICS geolevels_cb_2014_us_500k;
GO

-- SQL statement 194: Describe table geography_cb_2014_us_500k >>>
-- EXEC sp_help geography_cb_2014_us_500k;
GO

-- SQL statement 195: Analyze table geography_cb_2014_us_500k >>>
UPDATE STATISTICS geography_cb_2014_us_500k;
GO

-- SQL statement 196: Describe table hierarchy_cb_2014_us_500k >>>
-- EXEC sp_help hierarchy_cb_2014_us_500k;
GO

-- SQL statement 197: Analyze table hierarchy_cb_2014_us_500k >>>
UPDATE STATISTICS hierarchy_cb_2014_us_500k;
GO


--
-- EOF
